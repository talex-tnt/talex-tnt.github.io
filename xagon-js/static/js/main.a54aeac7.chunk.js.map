{"version":3,"sources":["models/Triangle.ts","game-constants/identifiers.ts","game-constants/index.ts","rendering/TriangleMesh/EquilateralTriangleProvider.ts","models/Icosahedron/index.ts","components/GameComponent/InputManager/FlipGesture.ts","models/Icosahedron/SubdivisionStrategy/1to4SubdivisionStrategy.ts","utils/math.ts","rendering/TriangleMesh/State/IMeshState.ts","components/GameComponent/InputManager/Gesture.ts","utils/scene.ts","rendering/TriangleMesh/State/MeshStateRotating.ts","rendering/TriangleMesh/State/MeshStateIdle.ts","rendering/TriangleMesh/index.ts","deserializers/JsonIcosahedronDeserializer.ts","gameplay/utils/index.ts","gameplay/ShapeDetector/shapesVerify.ts","components/GameComponent/setupCamera.tsx","components/GameComponent/setupLight.tsx","components/GameComponent/InputManager/setupInput/generateInputMesh.tsx","components/GameComponent/InputManager/setupInput/index.tsx","components/GameComponent/InputManager/index.tsx","gameplay/game/useGameLogic.ts","components/SceneComponent.tsx","components/GameComponent/index.tsx","reportWebVitals.ts","index.tsx"],"names":["TriangleEdge","Type","k_triangleAssetName","k_epsilon","EquilateralTriangleProvider","colors","First","Color3","Blue","Second","Red","Third","Yellow","Fourth","Green","Fifth","Purple","Sixth","Gray","typesCount","Object","keys","length","Triangle","id","p1","p2","p3","type","getRandomType","vertices","triangleId","adjacents","this","getId","middlePoint1","Vector3","Center","center1","add","subtract","scale","middlePoint2","center2","middlePoint3","center3","middlePoint","triangle","index","console","assert","find","tr","push","isAdjacent","adj","Math","floor","random","getTypesCount","Icosahedron","context","triangles","triangleCount","subdivisionStrategy","onTrianglesChanged","computeRegularIcosahedronTriangles","computeAdjacentTriangles","genTriangleId","b","sqrt","points","map","Normalize","indices","count","i","subdivide","onTriangleChanged","changes","equilateralTriangle","edgeLength1","toFixed","edgeLength2","edgeLength3","warn","findPointIndex","point","getVertices","findIndex","trPoint","abs","forEach","tr1","tr2","adjacentIndices","filter","indicesSum","setAdjacent","Direction","_1to4SubdivisionStrategy","icosahedron","getTriangles","reduce","prev","curr","subdivideTriangle","subTriangles","makeTriangle","setType","angle90","PI","angle120","IMeshState","Gesture","FlipGesture","firstTriangleMesh","secondTriangleMesh","startPoint","Vector2","Zero","lastEventTimestamp","pointerInfo","mesh","pickInfo","hit","pickedMesh","event","x","y","Date","now","getTriangleMesh","pickinfo","scene","pick","pointerX","pointerY","pressure","firstTriangle","getTriangle","finalPoint","metadata","assetMesh","assetMeshID","getAdjacents","a","secondTriangle","flipEnded","swapType","trM1","trM2","tr1Type","getType","tr2Type","reset","notifyTrianglesChanged","flip","triangleMesh","direction","Up","onFlipEnd","onFlipEnded","Down","originalMesh","name","getName","getMeshByName","getAssetMesh","computeObjSpaceVertices","scalingRatio","getScalingRatio","scaledVertices","v","edges","computeObjSpaceEdges","setVertices","setEdges","MeshStateRotating","thisTriangleMesh","adjacentTriangleMesh","nextState","adjacentMesh","rotation","axis","angle","flipNode","scalingNode","node","originalPosition","finalPosition","rotationAngle","skeleton","bones","bonesScaling","bonesIndices","bonesDeformation","adjBonesScalingY","amount","adjacentsVerticesMap","getAdjacentsVerticesMap","trMesh","parent","thisTriangleAdjVertIndices","trAdjs","computeRotationAxis","computeFlipNodePosition","rotationData","computeRotationData","rotationDownAngle","scalingNodeShiftRatio","adjRotationVector","rotationVector","centerShiftVector","computeCenterShiftVector","position","clone","getBonesIndices","getBonesScaling","adjTriangleAdjVertIndices","adjTrAdjs","computeAdjBonesScalingY","adjTriangleNotAdjVertexIndex","e","adjTriangleVertIndex","computeNodeRotationAngleToVertex","computeBonesDeformation","vertIndices","vertIndicesSum","getTriangleMeshIndicesSum","edgeIndex","getTriangleMeshFlipEdgeIndex","getEdges","flipNodeCenter","edgeCenterPoint","setPositionWithLocalVector","worldSpaceVertices","triangleMeshMatrix","computeWorldMatrix","centerADJ","TransformCoordinates","getCenterPoint","Matrix","Invert","point1","computeVectorProjectionPoint","index1","index2","point2","center","vectorCenterPoint","adjVectorCenterPoint","normal","Cross","GetAngleBetweenVectors","worldSpaceAdjEdgeCenterPoint","worldSpaceAdjEdge","projectionAngle","scalarProjection","cos","verticesMap","adjVertices","adjVertIndices","deltaCenterShift","computeVectorProjectionRatio","vectorCenterVertex","edgeVector","normalToComputeAngle","adjBonesIndices","getTriangleMeshBonesIndices","notAdjBoneIndex","scaling","boneScaling","One","adjTriangleMesh","vertexIndex","matrix","computeFinPosWorldMatrix","rotatedCenterPoint","rotatedWorldVertices","adjTriangle","adjTriangleCenter","adjPointCenterVector","rotationQuaternion","Quaternion","RotationAxis","rotationNode","rotatedTriangleVertices","computeRotatedTriangleVertices","bonesRotations","computeBonesRotationAngle","BigInt","bonesFirstRotations","getAngleBonesRotation","rotatedTriangleIndices","rotationSpeed","getRotationSpeed","deltaTimeInMs","getEngine","getDeltaTime","setupNodesOnFlipping","setupBonesOnFlipping","completeFlipping","Scalar","LerpAngle","Lerp","slice","setRotation","bonesScaleY","boneIndex","setScale","z","MeshStateIdle","args","TriangleMesh","equilateralTriangleProvider","triangleEdges","triangleVertices","equilateralTriangleRadius","skeletonBonesScaling","skeletonBonesRotation","bonesRotationAngle","scalingNodeInitialPosition","currentState","TRIANGLE_SIDE","findEquilateralTriangle","triangleEdgeLength","createNodesStructure","setupPosition","angleBonesRotation","setAngleBonesRotation","rotations","computeBonesScaling","bone","setupMaterial","rootNode","getNodeByName","positionNode","TransformNode","Identity","triangleMeshScalingRatio","triangleCenter","pitchCorrection","math","setDirection","p1CenterVector","forward","up","rotate","p2CenterVector","p3CenterVector","angleP1ToP3","angleP1ToP2","skeletonMesh","bone1rotation","bone2rotation","bone3rotation","material","StandardMaterial","diffuseColor","getColor","backFaceCulling","alpha","update","trVertices","adjTrVertices","adjacentsMap","trVertice","indexTrVertice","adjTrVertice","indexAdjTrVertice","verticeIndices","k","JsonIcosahedronDeserializer","version","descriptor","parsed","JSON","parse","key","value","jsonTriangleMap","_x","_y","_z","triangleMap","idx","isDuplicated","hasPoint","p","haveSameType","shapesVerify","shapes","pivotPoint","adjsPivotPoint","getAdjacentsToPoint","findHexagon","hex","adjs","shape","adjs2","adj2","adjs3","adj3","setupCamera","target","beta","camera","ArcRotateCamera","minZ","lowerRadiusLimit","setupLight","light","HemisphericLight","intensity","setDirectionToTarget","getMeshName","createVertexData","renderNormals","normals","positions","vertexData","VertexData","ComputeNormals","options","updatable","MeshBuilder","CreateLines","color","createMesh","customMesh","Mesh","isPickable","hue","HSVtoRGBToRef","applyToMesh","generateInputMesh","meshName","setupInput","canvas","getRenderingCanvas","attachControl","InputManager","gesturesMap","onPointerObservable","pointerId","PointerEventTypes","POINTERDOWN","POINTERTAP","gestureContext","onDown","POINTERMOVE","gesture","onMove","POINTERUP","onRelease","useGameLogic","loadIcosahedron","fetch","then","response","text","json","log","deserializer","deserialize","onSceneReady","sceneArg","inputs","attached","pointers","buttons","registerOnTriangleChanged","hexagons","inputManager","SceneLoader","ImportMeshAsync","meshes","skeletons","triangleMeshes","visibility","registerBeforeRender","t","onMeshLoaded","onRender","getTransformNodeByName","SceneComponent","props","reactCanvas","useRef","antialias","engineOptions","adaptToDeviceRatio","sceneOptions","rest","useEffect","current","engine","Engine","Scene","isReady","onReadyObservable","addOnce","observedScene","runRenderLoop","render","resize","window","addEventListener","dispose","removeEventListener","ref","width","innerWidth","height","innerHeight","GameComponent","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","basename","path","element","document","getElementById"],"mappings":"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","file":"static/js/main.a54aeac7.chunk.js","sourcesContent":["import { Nullable, Vector3, Color3 } from '@babylonjs/core';\n\nexport type TriangleVertices = Array<Vector3>;\nexport type TriangleId = bigint;\nexport type AdjacentTriangles = Array<AdjacentTriangle>;\nexport type AdjacentTriangle = Nullable<Triangle>;\n\nexport enum TriangleEdge {\n  First = 0,\n  Second,\n  Third,\n}\n\nexport enum Type {\n  First = 0,\n  Second,\n  Third,\n  Fourth,\n  Fifth,\n  Sixth,\n}\nexport const getTypeCount = (): number => Object.keys(Type).length / 2;\n\nconst colors: Record<Type, Color3> = {\n  [Type.First]: Color3.Blue(),\n  [Type.Second]: Color3.Red(),\n  [Type.Third]: Color3.Yellow(),\n  [Type.Fourth]: Color3.Green(),\n  [Type.Fifth]: Color3.Purple(),\n  [Type.Sixth]: Color3.Gray(),\n};\n\nconst typesCount = Object.keys(Type).length * 0.5;\n\nclass Triangle {\n  //\n  private vertices: TriangleVertices;\n\n  private triangleId: TriangleId;\n\n  private adjacents: AdjacentTriangles = [];\n\n  private type: Type = Type.First;\n\n  public constructor(\n    id: TriangleId,\n    p1: Vector3,\n    p2: Vector3,\n    p3: Vector3,\n    type: Type = Triangle.getRandomType(),\n  ) {\n    this.triangleId = id;\n    this.vertices = [p1, p2, p3];\n    this.type = type;\n  }\n\n  static getTypesCount(): number {\n    return typesCount;\n  }\n\n  static getRandomType(): number {\n    return Math.floor(Math.random() * Triangle.getTypesCount());\n  }\n\n  public getType(): Type {\n    return this.type;\n  }\n\n  public setType(type: Type): void {\n    this.type = type;\n  }\n\n  public getColor(): Color3 {\n    return colors[this.type];\n  }\n\n  public getId(): TriangleId {\n    return this.triangleId;\n  }\n\n  public getName(): string {\n    return `Triangle${this.getId()}`;\n  }\n\n  public p1(): Vector3 {\n    return this.vertices[0];\n  }\n\n  public p2(): Vector3 {\n    return this.vertices[1];\n  }\n\n  public p3(): Vector3 {\n    return this.vertices[2];\n  }\n\n  public getVertices(): TriangleVertices {\n    return this.vertices;\n  }\n\n  public getCenterPoint(): Vector3 {\n    const middlePoint1 = Vector3.Center(this.vertices[0], this.vertices[1]);\n    const center1 = this.vertices[2].add(\n      middlePoint1.subtract(this.vertices[2]).scale(2 / 3),\n    );\n    const middlePoint2 = Vector3.Center(this.vertices[1], this.vertices[2]);\n    const center2 = this.vertices[0].add(\n      middlePoint2.subtract(this.vertices[0]).scale(2 / 3),\n    );\n    const middlePoint3 = Vector3.Center(this.vertices[2], this.vertices[0]);\n    const center3 = this.vertices[1].add(\n      middlePoint3.subtract(this.vertices[1]).scale(2 / 3),\n    );\n    const middlePoint = Vector3.Center(center2, center3);\n    const center = center1.add(middlePoint.subtract(center1).scale(2 / 3));\n\n    return center;\n  }\n\n  public getAdjacents(): AdjacentTriangles {\n    return this.adjacents;\n  }\n\n  public setAdjacent(triangle: AdjacentTriangle, index: TriangleEdge): void {\n    this.adjacents[index] = triangle;\n  }\n\n  public pushAdjacent(triangle: Triangle): void {\n    // eslint-disable-next-line no-console\n    console.assert(this.adjacents.length <= 3, 'FATAL ERROR!!!');\n    if (!this.adjacents.find((tr) => tr?.getId() === triangle.getId())) {\n      this.adjacents.push(triangle);\n    }\n  }\n\n  public isAdjacent(triangle: Triangle): boolean {\n    const isAdjacent = this.adjacents.find(\n      (adj) => adj?.getId() === triangle.getId(),\n    );\n    if (isAdjacent) {\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default Triangle;\n","export const k_triangleAssetName = 'TriangleMesh';\nexport const k_triangleAssetFileName = 'triangle.babylon';\nexport const k_triangleAssetDebugFileName = 'triangleDebug.babylon';\nexport const k_triangleAssetPath = './assets/models/';\n","export const k_triangleScale = 0.95;\nexport const k_epsilon = 0.00000001;\nexport const k_gestureDeltaTimeThreshold = 300;\nexport const k_gestureLength = 40;\n","import Triangle from 'models/Triangle';\n\nabstract class EquilateralTriangleProvider {\n  public abstract findEquilateralTriangle(): Triangle;\n}\n\nexport default EquilateralTriangleProvider;\n","import { Vector3 } from '@babylonjs/core';\nimport { k_epsilon } from 'game-constants';\nimport EquilateralTriangleProvider from 'rendering/TriangleMesh/EquilateralTriangleProvider';\nimport Triangle from 'models/Triangle';\nimport ISubdivisionStrategy from './SubdivisionStrategy/ISubdivisionStrategy';\nexport type Triangles = Array<Triangle>;\ninterface Context {\n  subdivisionStrategy: ISubdivisionStrategy;\n  triangles?: Triangles;\n}\nclass Icosahedron extends EquilateralTriangleProvider {\n  //\n  private triangles: Triangles;\n\n  private triangleCount = 0n;\n\n  private subdivisionStrategy: ISubdivisionStrategy;\n\n  private onTrianglesChanged: (triangles: Triangle[]) => void = () => undefined;\n\n  private genTriangleId(): bigint {\n    this.triangleCount += 1n;\n    return this.triangleCount;\n  }\n\n  public makeTriangle(p1: Vector3, p2: Vector3, p3: Vector3): Triangle {\n    return new Triangle(this.genTriangleId(), p1, p2, p3);\n  }\n\n  public constructor(context: Context) {\n    super();\n    this.subdivisionStrategy = context.subdivisionStrategy;\n    if (context.triangles) {\n      this.triangles = context.triangles;\n    } else {\n      this.triangles = this.computeRegularIcosahedronTriangles();\n      computeAdjacentTriangles(this.triangles);\n    }\n  }\n\n  private computeRegularIcosahedronTriangles() {\n    const phi = (1.0 + Math.sqrt(5.0)) * 0.5; // golden ratio\n    const a = 1.0;\n    const b = 1.0 / phi;\n\n    const points = [\n      new Vector3(0, b, -a),\n      new Vector3(b, a, 0),\n      new Vector3(-b, a, 0),\n      new Vector3(0, b, a),\n      new Vector3(0, -b, a),\n      new Vector3(-a, 0, b),\n      new Vector3(0, -b, -a),\n      new Vector3(a, 0, -b),\n      new Vector3(a, 0, b),\n      new Vector3(-a, 0, -b),\n      new Vector3(b, -a, 0),\n      new Vector3(-b, -a, 0),\n    ].map(Vector3.Normalize);\n\n    const makeTriangle = (indices: Array<number>) =>\n      new Triangle(\n        this.genTriangleId(),\n        points[indices[0]],\n        points[indices[1]],\n        points[indices[2]],\n      );\n\n    const triangles = [\n      [0, 1, 2],\n      [3, 2, 1],\n      [3, 4, 5],\n      [3, 8, 4],\n      [0, 6, 7],\n      [0, 9, 6],\n      [4, 10, 11],\n      [6, 11, 10],\n      [2, 5, 9],\n      [11, 9, 5],\n      [1, 7, 8],\n      [10, 8, 7],\n      [3, 5, 2],\n      [3, 1, 8],\n      [0, 2, 9],\n      [0, 7, 1],\n      [6, 9, 11],\n      [6, 10, 7],\n      [4, 11, 5],\n      [4, 8, 10],\n    ].map(makeTriangle);\n    return triangles;\n  }\n\n  public getTriangles(): Array<Triangle> {\n    return this.triangles;\n  }\n\n  public subdivide(count = 1): void {\n    for (let i = 0; i < count; i += 1) {\n      this.triangles = this.subdivisionStrategy.subdivide(this);\n    }\n    computeAdjacentTriangles(this.triangles);\n  }\n\n  public registerOnTriangleChanged(\n    onTriangleChanged: (triangles: Triangle[]) => void,\n  ): void {\n    this.onTrianglesChanged = onTriangleChanged;\n  }\n\n  public notifyTrianglesChanged(changes: Triangle[]): void {\n    this.onTrianglesChanged(changes);\n  }\n\n  public findEquilateralTriangle(): Triangle {\n    const fractionDigits = 8;\n    const equilateralTriangle = this.triangles.find((tr) => {\n      const edgeLength1 = tr\n        .p1()\n        .subtract(tr.p2())\n        .length()\n        .toFixed(fractionDigits);\n      const edgeLength2 = tr\n        .p2()\n        .subtract(tr.p3())\n        .length()\n        .toFixed(fractionDigits);\n      const edgeLength3 = tr\n        .p3()\n        .subtract(tr.p1())\n        .length()\n        .toFixed(fractionDigits);\n\n      return edgeLength1 === edgeLength2 && edgeLength2 === edgeLength3;\n    });\n    if (!equilateralTriangle) {\n      // eslint-disable-next-line no-console\n      console.warn('Equilateral Triangle not found');\n      // eslint-disable-next-line no-debugger\n      debugger;\n    }\n    return equilateralTriangle || this.triangles[0]; // this.triangles[0] shouldn't ever been returned\n  }\n}\n\nfunction computeAdjacentTriangles(triangles: Triangle[]) {\n  const findPointIndex = (triangle: Triangle, point: Vector3): number =>\n    triangle\n\n      .getVertices()\n\n      .findIndex(\n        (trPoint: Vector3) =>\n          Math.abs(point.subtract(trPoint).length()) < k_epsilon,\n      );\n  triangles.forEach((tr1) => {\n    triangles.forEach((tr2) => {\n      if (tr1.getId() !== tr2.getId()) {\n        const adjacentIndices = [\n          findPointIndex(tr1, tr2.p1()),\n          findPointIndex(tr1, tr2.p2()),\n          findPointIndex(tr1, tr2.p3()),\n        ].filter((i) => i !== -1);\n\n        if (adjacentIndices.length === 2) {\n          const firstIndex = adjacentIndices[0] as number;\n          const secondIndex = adjacentIndices[1] as number;\n\n          const indicesSum = firstIndex + secondIndex;\n          // sum = 1 if indices [0, 1] || [1, 0]\n          // sum = 2 if indices [0, 2] || [2, 0]\n          // sum = 3 if indices [1, 2] || [2, 1]\n          if (indicesSum === 1) {\n            tr1.setAdjacent(tr2, 0);\n          }\n          if (indicesSum === 3) {\n            tr1.setAdjacent(tr2, 1);\n          }\n          if (indicesSum === 2) {\n            tr1.setAdjacent(tr2, 2);\n          }\n        }\n      }\n    });\n  });\n}\n\nexport default Icosahedron;\n","import {\n  AbstractMesh,\n  PointerInfo,\n  Scene,\n  Nullable,\n  Vector2,\n  Vector3,\n} from '@babylonjs/core';\nimport { k_gestureLength, k_gestureDeltaTimeThreshold } from 'game-constants';\nimport TriangleMesh from 'rendering/TriangleMesh';\nimport { getAssetMesh } from 'utils/scene';\nimport Gesture from './Gesture';\n\ninterface GestureContext {\n  scene: Scene;\n  triangleMesh: AbstractMesh;\n  onFlipEnded: () => void;\n}\n\nexport enum Direction {\n  Up = 1,\n  Down,\n}\n\nclass FlipGesture extends Gesture {\n  private context: GestureContext;\n\n  private firstTriangleMesh: Nullable<TriangleMesh>;\n\n  private secondTriangleMesh: Nullable<TriangleMesh>;\n\n  private startPoint: Vector2 = Vector2.Zero();\n\n  private lastEventTimestamp = 0;\n\n  public constructor(context: GestureContext) {\n    super();\n    this.context = context;\n    this.firstTriangleMesh = null;\n    this.secondTriangleMesh = null;\n  }\n\n  public onDown(pointerInfo: PointerInfo): void {\n    const mesh = pointerInfo?.pickInfo?.hit && pointerInfo.pickInfo.pickedMesh;\n\n    if (pointerInfo.event) {\n      this.startPoint = new Vector2(pointerInfo.event.x, pointerInfo.event.y);\n      this.lastEventTimestamp = Date.now();\n    }\n    if (mesh) {\n      this.firstTriangleMesh = this.getTriangleMesh(mesh);\n    }\n  }\n\n  public onMove(pointerInfo: PointerInfo): void {\n    const pickinfo = this.context.scene.pick(\n      this.context.scene.pointerX,\n      this.context.scene.pointerY,\n    );\n    if (pickinfo && pointerInfo.event.pressure !== 0) {\n      const mesh = pickinfo.pickedMesh;\n\n      if (!this.firstTriangleMesh && mesh) {\n        this.firstTriangleMesh = this.getTriangleMesh(mesh);\n        this.startPoint = new Vector2(\n          this.context.scene.pointerX,\n          this.context.scene.pointerY,\n        );\n        this.lastEventTimestamp = Date.now();\n      }\n\n      if (this.firstTriangleMesh) {\n        const firstTriangle = this.firstTriangleMesh.getTriangle();\n\n        const now = Date.now();\n        const deltaTime = now - this.lastEventTimestamp;\n\n        if (deltaTime > k_gestureDeltaTimeThreshold) {\n          this.startPoint = new Vector2(\n            this.context.scene.pointerX,\n            this.context.scene.pointerY,\n          );\n        } else {\n          const finalPoint = new Vector2(\n            this.context.scene.pointerX,\n            this.context.scene.pointerY,\n          );\n\n          const gestureLength = this.startPoint.subtract(finalPoint).length();\n\n          const isValidGesture = gestureLength > k_gestureLength;\n\n          if (isValidGesture) {\n            if (\n              mesh &&\n              mesh.metadata &&\n              mesh.metadata.triangle &&\n              mesh.metadata.triangle.getId() !== firstTriangle.getId()\n            ) {\n              const assetMesh = this.getTriangleMesh(mesh);\n\n              if (assetMesh) {\n                const assetMeshID = assetMesh.getTriangle().getId();\n\n                const isAdjacent = !!this.firstTriangleMesh\n                  .getTriangle()\n                  .getAdjacents()\n                  .find((a) => a?.getId() === assetMeshID);\n\n                if (isAdjacent) {\n                  this.secondTriangleMesh = assetMesh;\n                }\n              }\n\n              if (this.secondTriangleMesh) {\n                const secondTriangle = this.secondTriangleMesh.getTriangle();\n                if (firstTriangle.isAdjacent(secondTriangle)) {\n                  let flipEnded = false;\n                  const swapType = (trM1: TriangleMesh, trM2: TriangleMesh) => {\n                    if (trM1 && trM2) {\n                      const tr1 = trM1.getTriangle();\n                      const tr2 = trM2.getTriangle();\n                      const tr1Type = tr1.getType();\n                      const tr2Type = tr2.getType();\n\n                      trM1.reset(tr2Type);\n                      trM2.reset(tr1Type);\n                      const { icosahedron } = this.context.scene.metadata;\n\n                      icosahedron.notifyTrianglesChanged([tr1, tr2]);\n                    }\n                  };\n\n                  this.firstTriangleMesh.flip({\n                    triangleMesh: this.secondTriangleMesh,\n                    direction: Direction.Up,\n                    onFlipEnd: () => {\n                      if (\n                        flipEnded &&\n                        this.firstTriangleMesh &&\n                        this.secondTriangleMesh\n                      ) {\n                        swapType(\n                          this.firstTriangleMesh,\n                          this.secondTriangleMesh,\n                        );\n                        this.context.onFlipEnded();\n                      }\n                      flipEnded = true;\n                    },\n                  });\n                  this.secondTriangleMesh.flip({\n                    triangleMesh: this.firstTriangleMesh,\n                    direction: Direction.Down,\n                    onFlipEnd: () => {\n                      if (\n                        flipEnded &&\n                        this.firstTriangleMesh &&\n                        this.secondTriangleMesh\n                      ) {\n                        swapType(\n                          this.firstTriangleMesh,\n                          this.secondTriangleMesh,\n                        );\n                        this.context.onFlipEnded();\n                      }\n                      flipEnded = true;\n                    },\n                  });\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  public onRelease(pointerInfo: PointerInfo): void {\n    //\n  }\n\n  public getTriangleMesh(mesh: AbstractMesh): Nullable<TriangleMesh> {\n    const originalMesh = getAssetMesh({\n      scene: this.context.scene,\n      triangleMesh: mesh,\n    });\n\n    if (originalMesh) {\n      const { triangleMesh } = originalMesh.metadata;\n      if (triangleMesh) {\n        const vertices = triangleMesh.computeObjSpaceVertices();\n        const scalingRatio = triangleMesh.getScalingRatio();\n        const scaledVertices = vertices.map((v: Vector3) =>\n          v.scale(scalingRatio),\n        );\n        const edges = triangleMesh.computeObjSpaceEdges(scaledVertices);\n\n        if (scaledVertices && edges) {\n          triangleMesh.setVertices(scaledVertices);\n          triangleMesh.setEdges(edges);\n\n          return triangleMesh;\n        }\n      }\n    }\n    return null;\n  }\n}\n\nexport default FlipGesture;\n","import { Vector3 } from '@babylonjs/core';\nimport ISubdivisionStrategy, {\n  Triangles,\n  Triangle,\n  Icosahedron,\n} from './ISubdivisionStrategy';\n\nclass _1to4SubdivisionStrategy implements ISubdivisionStrategy {\n  public subdivide(icosahedron: Icosahedron): Triangles {\n    return icosahedron\n      .getTriangles()\n      .reduce(\n        (prev: Array<Triangle>, curr: Triangle) => [\n          ...prev,\n          ...subdivideTriangle(curr, icosahedron),\n        ],\n        [],\n      );\n  }\n}\nexport default _1to4SubdivisionStrategy;\n\nconst subdivideTriangle = (\n  triangle: Triangle,\n  icosahedron: Icosahedron,\n): Triangles => {\n  const center1 = Vector3.Center(triangle.p2(), triangle.p1());\n  const center2 = Vector3.Center(triangle.p3(), triangle.p2());\n  const center3 = Vector3.Center(triangle.p1(), triangle.p3());\n\n  const p1 = center1.scale(1 / center1.length());\n  const p2 = center2.scale(1 / center2.length());\n  const p3 = center3.scale(1 / center3.length());\n\n  const subTriangles = [\n    icosahedron.makeTriangle(triangle.p1(), p1, p3),\n    icosahedron.makeTriangle(p1, triangle.p2(), p2),\n    icosahedron.makeTriangle(p1, p2, p3),\n    icosahedron.makeTriangle(p3, p2, triangle.p3()),\n  ];\n\n  subTriangles.forEach((tr) => tr.setType(Triangle.getRandomType()));\n\n  return subTriangles;\n};\n","export default {\n  angle90: Math.PI * 0.5,\n  angle120: Math.PI * (2 / 3),\n};\n","import { Nullable } from '@babylonjs/core';\nimport TriangleMesh from '..';\n\nabstract class IMeshState {\n  abstract update(\n    args?: Nullable<{\n      direction?: number;\n      adjacentTriangleMesh?: Nullable<TriangleMesh>;\n    }>,\n  ): Nullable<IMeshState>;\n}\nexport default IMeshState;\n","import { PointerInfo } from '@babylonjs/core';\nexport type GestureId = number;\n\nabstract class Gesture {\n  public abstract onDown(pointerInfo: PointerInfo): void;\n\n  public abstract onMove(pointerInfo: PointerInfo): void;\n\n  public abstract onRelease(pointerInfo: PointerInfo): void;\n}\n\nexport default Gesture;\n","import { Nullable, AbstractMesh, Scene } from '@babylonjs/core';\nexport const getAssetMesh = ({\n  scene,\n  triangleMesh,\n}: {\n  scene: Scene;\n  triangleMesh: Nullable<AbstractMesh>;\n}): Nullable<AbstractMesh> => {\n  if (triangleMesh && triangleMesh.metadata && triangleMesh.metadata.triangle) {\n    const name = triangleMesh.metadata.triangle.getName();\n    const assetMesh = scene.getMeshByName(name);\n    if (assetMesh) {\n      return assetMesh;\n    }\n    // eslint-disable-next-line no-console\n    console.assert(typeof assetMesh === 'object', 'Asset not found');\n  }\n  return null;\n};\n","import {\n  Nullable,\n  Quaternion,\n  Scene,\n  TransformNode,\n  Vector3,\n  Scalar,\n  Bone,\n  MeshBuilder,\n  Color3,\n  StandardMaterial,\n  Matrix,\n} from '@babylonjs/core';\nimport { Direction } from 'components/GameComponent/InputManager/FlipGesture';\nimport {\n  DEBUG_RENDERING_TRIANGLES_CENTER_DURING_ROTATION,\n  DEBUG_RENDERING_BONES_IDENTIFIER,\n} from 'game-constants/debug';\nimport Triangle from 'models/Triangle';\nimport TriangleMesh from '..';\nimport IMeshState from './IMeshState';\nimport MeshStateIdle from './MeshStateIdle';\n\nclass MeshStateRotating extends IMeshState {\n  private nextState: Nullable<IMeshState> = null;\n\n  private scene: Scene;\n\n  private mesh: TriangleMesh;\n\n  private adjacentMesh: TriangleMesh;\n\n  private rotation: {\n    axis: Vector3;\n    angle: number;\n  } = {\n    axis: Vector3.Zero(),\n    angle: 0,\n  };\n\n  private flipNode: Nullable<TransformNode> = null;\n\n  private scalingNode: {\n    node: Nullable<TransformNode>;\n    originalPosition: Vector3;\n    finalPosition: Vector3;\n    rotationAngle: number;\n  } = {\n    node: null,\n    originalPosition: Vector3.Zero(),\n    finalPosition: Vector3.Zero(),\n    rotationAngle: 0,\n  };\n\n  private skeleton: {\n    bones: Nullable<Bone[]>;\n    bonesScaling: Nullable<Vector3>[];\n    bonesIndices: number[];\n    bonesDeformation: number[];\n  } = {\n    bones: [],\n    bonesScaling: [],\n    bonesIndices: [],\n    bonesDeformation: [],\n  };\n\n  private adjBonesScalingY: number[] = [];\n\n  private amount = 0;\n\n  private onFlipEnd?: () => void;\n\n  public constructor({\n    thisTriangleMesh,\n    adjacentTriangleMesh,\n    scene,\n    direction,\n    onFlipEnd,\n  }: {\n    thisTriangleMesh: TriangleMesh;\n    adjacentTriangleMesh: TriangleMesh;\n    scene: Scene;\n    direction?: number;\n    onFlipEnd?: () => void;\n  }) {\n    super();\n    this.scene = scene;\n    this.onFlipEnd = onFlipEnd;\n    this.mesh = thisTriangleMesh;\n    this.adjacentMesh = adjacentTriangleMesh;\n\n    const adjacentsVerticesMap = this.mesh.getAdjacentsVerticesMap(\n      this.adjacentMesh.getTriangle(),\n    );\n\n    const trMesh = this.mesh.getTriangleMesh();\n    if (trMesh) {\n      this.scalingNode.node = trMesh.parent as TransformNode;\n\n      const thisTriangleAdjVertIndices = adjacentsVerticesMap.trAdjs;\n\n      this.rotation.axis = this.computeRotationAxis(thisTriangleAdjVertIndices);\n\n      this.flipNode = this.computeFlipNodePosition(thisTriangleAdjVertIndices);\n\n      const rotationData = this.computeRotationData(thisTriangleAdjVertIndices);\n\n      if (rotationData) {\n        if (direction === Direction.Down) {\n          this.rotation.angle = -rotationData.rotationDownAngle;\n        } else {\n          this.rotation.angle = Math.PI * 2 - rotationData.rotationDownAngle;\n        }\n        // computing length ratio between vector (edge's center - mesh's center) of the first triangle and vector (edge's center - mesh's center) of the second triangle to shift the scaling node during rotation\n        const scalingNodeShiftRatio =\n          rotationData.adjRotationVector.length() /\n          rotationData.rotationVector.length();\n\n        const centerShiftVector =\n          this.computeCenterShiftVector(adjacentsVerticesMap);\n\n        this.scalingNode.originalPosition =\n          this.scalingNode.node.position.clone();\n        this.scalingNode.finalPosition = this.scalingNode.originalPosition\n          .scale(scalingNodeShiftRatio)\n          .subtract(centerShiftVector);\n\n        this.skeleton.bones = trMesh.skeleton && trMesh.skeleton.bones;\n        this.skeleton.bonesIndices = this.getBonesIndices(\n          thisTriangleAdjVertIndices,\n        );\n        this.skeleton.bonesScaling = this.getBonesScaling();\n\n        const adjTriangleAdjVertIndices = adjacentsVerticesMap.adjTrAdjs;\n        this.adjBonesScalingY = this.computeAdjBonesScalingY(\n          adjTriangleAdjVertIndices,\n        );\n\n        const adjTriangleNotAdjVertexIndex = [0, 1, 2].findIndex(\n          (e) =>\n            e !== adjTriangleAdjVertIndices[0] &&\n            e !== adjTriangleAdjVertIndices[1],\n        );\n\n        const index = thisTriangleAdjVertIndices.findIndex((v) => v === 0);\n\n        const adjTriangleVertIndex =\n          index === -1\n            ? adjTriangleNotAdjVertexIndex\n            : adjTriangleAdjVertIndices[index];\n\n        this.scalingNode.rotationAngle =\n          this.computeNodeRotationAngleToVertex(adjTriangleVertIndex);\n\n        this.skeleton.bonesDeformation =\n          this.computeBonesDeformation(adjTriangleVertIndex);\n\n        if (DEBUG_RENDERING_BONES_IDENTIFIER) {\n          const vertices = this.mesh.getVertices();\n          if (vertices) {\n            // eslint-disable-next-line no-console\n            console.log(\n              'TriangleID - ',\n              this.mesh.getTriangle().getId(),\n              'AdjacentTriangleID - ',\n              this.adjacentMesh.getTriangle().getId(),\n            );\n            const meshSPHERE1 = MeshBuilder.CreateSphere(\n              `tr1${this.mesh.getTriangle().getName()}`,\n              {\n                diameter: 0.1,\n              },\n            );\n            meshSPHERE1.parent = this.scalingNode.node;\n            meshSPHERE1.position = vertices[0].scale(1.5);\n            const mat1 = new StandardMaterial(`color${vertices[0]}`, scene);\n            mat1.diffuseColor = new Color3(0, 0, 1);\n            meshSPHERE1.material = mat1;\n            const meshSPHERE2 = MeshBuilder.CreateSphere(\n              `tr2${this.mesh.getTriangle().getName()}`,\n              {\n                diameter: 0.1,\n              },\n            );\n            meshSPHERE2.parent = this.scalingNode.node;\n            meshSPHERE2.position = vertices[1].scale(1.5);\n            const mat2 = new StandardMaterial(`color${vertices[1]}`, scene);\n            mat2.diffuseColor = new Color3(0, 1, 0);\n            meshSPHERE2.material = mat2;\n            const meshSPHERE3 = MeshBuilder.CreateSphere(\n              `tr3${this.mesh.getTriangle().getName()}`,\n              {\n                diameter: 0.1,\n              },\n            );\n            meshSPHERE3.parent = this.scalingNode.node;\n            meshSPHERE3.position = vertices[2].scale(1.5);\n            const mat3 = new StandardMaterial(`color${vertices[2]}`, scene);\n            mat3.diffuseColor = new Color3(1, 0, 0);\n            meshSPHERE3.material = mat3;\n          }\n        }\n      }\n    }\n  }\n\n  private computeRotationAxis(vertIndices: number[]): Vector3 {\n    const vertIndicesSum = this.mesh.getTriangleMeshIndicesSum(vertIndices);\n    const edgeIndex = this.mesh.getTriangleMeshFlipEdgeIndex(vertIndicesSum);\n    const edges = this.mesh.getEdges() as Vector3[];\n\n    return edges[edgeIndex];\n  }\n\n  private computeFlipNodePosition(\n    vertIndices: number[],\n  ): Nullable<TransformNode> {\n    if (this.scalingNode.node) {\n      const flipNode = this.scalingNode.node.parent as TransformNode;\n      const vertices = this.mesh.getVertices();\n      if (flipNode && vertices) {\n        const flipNodeCenter = Vector3.Zero(); // node position in object space\n        const edgeCenterPoint = Vector3.Center(\n          vertices[vertIndices[0]],\n          vertices[vertIndices[1]],\n        );\n\n        flipNode.setPositionWithLocalVector(edgeCenterPoint);\n        this.scalingNode.node.position = flipNodeCenter.subtract(\n          flipNode.position,\n        );\n        return flipNode;\n      }\n    }\n    return null;\n  }\n\n  private computeRotationData(indices: number[]): Nullable<{\n    rotationVector: Vector3;\n    adjRotationVector: Vector3;\n    rotationDownAngle: number;\n  }> {\n    const worldSpaceVertices = this.mesh.getTriangle().getVertices();\n\n    const triangleMesh = this.mesh.getTriangleMesh();\n\n    if (triangleMesh) {\n      const vertices = this.mesh.computeObjSpaceVertices();\n\n      if (vertices) {\n        const triangleMeshMatrix = triangleMesh.computeWorldMatrix(true);\n\n        const centerADJ = Vector3.TransformCoordinates(\n          this.adjacentMesh.getTriangle().getCenterPoint(),\n          Matrix.Invert(triangleMeshMatrix),\n        );\n\n        const point1 = this.computeVectorProjectionPoint({\n          vertices,\n          index1: indices[1],\n          index2: indices[0],\n        });\n        const point2 = this.computeVectorProjectionPoint({\n          vertices,\n          center: centerADJ,\n          index1: indices[0],\n          index2: indices[1],\n        });\n\n        const vectorCenterPoint = Vector3.Zero().subtract(point1);\n        const adjVectorCenterPoint = centerADJ.subtract(point2);\n        const normal = Vector3.Cross(vectorCenterPoint, adjVectorCenterPoint);\n\n        const rotationDownAngle = Math.abs(\n          Vector3.GetAngleBetweenVectors(\n            vectorCenterPoint,\n            adjVectorCenterPoint,\n            normal,\n          ),\n        );\n\n        const worldSpaceAdjEdgeCenterPoint = Vector3.Center(\n          worldSpaceVertices[indices[0]],\n          worldSpaceVertices[indices[1]],\n        );\n        const rotationVector = this.mesh\n          .getTriangle()\n          .getCenterPoint()\n          .subtract(worldSpaceAdjEdgeCenterPoint);\n        const adjRotationVector = this.adjacentMesh\n          .getTriangle()\n          .getCenterPoint()\n          .subtract(worldSpaceAdjEdgeCenterPoint);\n\n        return { rotationVector, adjRotationVector, rotationDownAngle };\n      }\n    }\n    return null;\n  }\n\n  private computeVectorProjectionPoint({\n    vertices,\n    center = Vector3.Zero(),\n    index1,\n    index2,\n  }: {\n    vertices: Vector3[];\n    center?: Vector3;\n    index1: number;\n    index2: number;\n  }): Vector3 {\n    const worldSpaceAdjEdge = vertices[index1].subtract(vertices[index2]);\n\n    const projectionAngle = Vector3.GetAngleBetweenVectors(\n      center.subtract(vertices[index2]),\n      worldSpaceAdjEdge,\n      Vector3.Cross(center.subtract(vertices[index2]), worldSpaceAdjEdge),\n    );\n\n    const scalarProjection =\n      center.subtract(vertices[index2]).length() * Math.cos(projectionAngle);\n\n    const point = vertices[index2].add(\n      worldSpaceAdjEdge.scale(scalarProjection / worldSpaceAdjEdge.length()),\n    );\n\n    return point;\n  }\n\n  private computeCenterShiftVector(\n    verticesMap: Record<string, number[]>,\n  ): Vector3 {\n    const adjVertices = this.adjacentMesh.getVertices();\n    const vertices = this.mesh.getVertices();\n    const vertIndices = verticesMap.trAdjs;\n    const adjVertIndices = verticesMap.adjTrAdjs;\n\n    if (adjVertices && vertices) {\n      const vectorProjectionRatio = this.computeVectorProjectionRatio(\n        vertices,\n        vertIndices,\n      );\n\n      const adjVectorProjectionRatio = this.computeVectorProjectionRatio(\n        adjVertices,\n        adjVertIndices,\n      );\n\n      const deltaCenterShift = vectorProjectionRatio - adjVectorProjectionRatio;\n\n      const edgeVector = vertices[vertIndices[1]].subtract(\n        vertices[vertIndices[0]],\n      );\n      const centerShiftVector = edgeVector.scale(deltaCenterShift);\n\n      return centerShiftVector;\n    }\n    return Vector3.Zero();\n  }\n\n  private computeVectorProjectionRatio(\n    vertices: Vector3[],\n    indices: number[],\n  ): number {\n    const vectorCenterVertex = Vector3.Zero().subtract(vertices[indices[0]]);\n    const edgeVector = vertices[indices[1]].subtract(vertices[indices[0]]);\n    const normalToComputeAngle = Vector3.Cross(vectorCenterVertex, edgeVector);\n\n    const projectionAngle = Vector3.GetAngleBetweenVectors(\n      vectorCenterVertex,\n      edgeVector,\n      normalToComputeAngle,\n    );\n\n    const scalarProjection =\n      vectorCenterVertex.length() * Math.cos(projectionAngle);\n\n    const vectorProjectionRatio = Math.abs(\n      scalarProjection / edgeVector.length(),\n    );\n\n    return vectorProjectionRatio;\n  }\n\n  private getBonesIndices(indices: number[]): number[] {\n    const adjBonesIndices = this.mesh.getTriangleMeshBonesIndices(indices);\n\n    const notAdjBoneIndex = [0, 1, 2].findIndex(\n      (e) => e !== adjBonesIndices[0] && e !== adjBonesIndices[1],\n    );\n\n    const bonesIndices = [...adjBonesIndices, notAdjBoneIndex];\n\n    return bonesIndices;\n  }\n\n  private getBonesScaling(): Vector3[] {\n    if (this.skeleton.bones) {\n      const firstBoneScaling =\n        this.skeleton.bones[this.skeleton.bonesIndices[0]].scaling;\n      const secondBoneScaling =\n        this.skeleton.bones[this.skeleton.bonesIndices[1]].scaling;\n      const notAdjBoneScaling =\n        this.skeleton.bones[this.skeleton.bonesIndices[2]].scaling;\n\n      const bonesScaling = [\n        firstBoneScaling,\n        secondBoneScaling,\n        notAdjBoneScaling,\n      ];\n      return bonesScaling.map((boneScaling) => boneScaling.clone());\n    }\n    // eslint-disable-next-line no-console\n    console.assert(this.skeleton.bones, 'Skeleton must exist');\n    return [Vector3.One(), Vector3.One(), Vector3.One()];\n  }\n\n  private computeAdjBonesScalingY(indices: number[]): number[] {\n    let adjBonesScalingY = [1, 1, 1];\n    const adjTriangleMesh = this.adjacentMesh.getTriangleMesh();\n\n    if (adjTriangleMesh) {\n      const skeleton =\n        adjTriangleMesh.skeleton && adjTriangleMesh.skeleton.bones;\n\n      if (skeleton) {\n        const bonesIndices =\n          this.adjacentMesh.getTriangleMeshBonesIndices(indices);\n        const notAdjBoneIndex = [0, 1, 2].findIndex(\n          (e) => e !== bonesIndices[0] && e !== bonesIndices[1],\n        );\n\n        adjBonesScalingY = [\n          skeleton[bonesIndices[0]].scaling.y,\n          skeleton[bonesIndices[1]].scaling.y,\n          skeleton[notAdjBoneIndex].scaling.y,\n        ];\n      }\n    }\n    return adjBonesScalingY;\n  }\n\n  private computeNodeRotationAngleToVertex(vertexIndex: number): number {\n    const matrix = this.computeFinPosWorldMatrix();\n\n    const rotatedCenterPoint = Vector3.TransformCoordinates(\n      new Vector3(0, 0, 0),\n      matrix,\n    );\n    const vertices = this.mesh.getVertices();\n\n    if (vertices) {\n      const rotatedWorldVertices = vertices.map((v) =>\n        Vector3.TransformCoordinates(v, matrix),\n      );\n\n      const adjTriangle = this.adjacentMesh.getTriangle();\n      const adjTriangleCenter = adjTriangle.getCenterPoint();\n      const adjTriangleVertices = adjTriangle.getVertices();\n      const adjPointCenterVector =\n        adjTriangleVertices[vertexIndex].subtract(adjTriangleCenter);\n\n      const nodeRotationAngle = Vector3.GetAngleBetweenVectors(\n        rotatedWorldVertices[0].subtract(rotatedCenterPoint),\n        adjPointCenterVector,\n        adjTriangleCenter,\n      );\n\n      return nodeRotationAngle;\n    }\n    return 0;\n  }\n\n  private computeFinPosWorldMatrix(): Matrix {\n    const mesh = this.mesh.getTriangleMesh();\n    if (mesh && this.flipNode && this.scalingNode.node) {\n      this.flipNode.rotationQuaternion = Quaternion.RotationAxis(\n        this.rotation.axis,\n        this.rotation.angle,\n      );\n      this.scalingNode.node.position = this.scalingNode.finalPosition;\n\n      const rotationNode = this.scalingNode.node.parent as TransformNode;\n      const positionNode = rotationNode.parent as TransformNode;\n      positionNode.computeWorldMatrix(true);\n      rotationNode.computeWorldMatrix(true);\n      this.flipNode.computeWorldMatrix(true);\n      this.scalingNode.node.computeWorldMatrix(true);\n      const matrix = mesh.computeWorldMatrix(true);\n\n      // RESET Nodes transformations after compute Matrix\n      this.flipNode.rotationQuaternion = Quaternion.RotationAxis(\n        this.rotation.axis,\n        0,\n      );\n      this.scalingNode.node.position = this.scalingNode.originalPosition;\n      return matrix;\n    }\n    // eslint-disable-next-line no-console\n    console.assert(mesh, 'Mesh must exist');\n    return Matrix.Zero();\n  }\n\n  private computeBonesDeformation(index: number): number[] {\n    const rotatedTriangleVertices = this.computeRotatedTriangleVertices(\n      this.adjacentMesh,\n      index,\n    );\n\n    const bonesRotations = this.adjacentMesh.computeBonesRotationAngle({\n      triangle: new Triangle(\n        BigInt(0),\n        rotatedTriangleVertices[0],\n        rotatedTriangleVertices[1],\n        rotatedTriangleVertices[2],\n      ),\n    });\n    const bonesFirstRotations = this.mesh.getAngleBonesRotation();\n\n    const bone1DeltaRotation = bonesFirstRotations[0] + bonesRotations[1];\n    const bone2DeltaRotation = bonesFirstRotations[1] + bonesRotations[0];\n\n    return [bone1DeltaRotation, bone2DeltaRotation];\n  }\n\n  private computeRotatedTriangleVertices(\n    mesh: TriangleMesh,\n    vertexIndex: number,\n  ): Vector3[] {\n    let rotatedTriangleIndices: number[] = [];\n    switch (vertexIndex) {\n      case 0: {\n        rotatedTriangleIndices = [0, 1, 2];\n        break;\n      }\n      case 1: {\n        rotatedTriangleIndices = [1, 2, 0];\n        break;\n      }\n      case 2: {\n        rotatedTriangleIndices = [2, 0, 1];\n        break;\n      }\n      default:\n    }\n    const vertices = mesh.getTriangle().getVertices();\n\n    const customTriangleVertices = rotatedTriangleIndices.map(\n      (i) => vertices[i],\n    );\n\n    return customTriangleVertices;\n  }\n\n  public update(): Nullable<IMeshState> {\n    const rotationSpeed = this.getRotationSpeed();\n    const deltaTimeInMs = this.scene.getEngine().getDeltaTime();\n    const { amount } = this;\n\n    if (amount < 1) {\n      this.setupNodesOnFlipping(amount);\n      this.setupBonesOnFlipping(amount);\n\n      this.amount += rotationSpeed * (deltaTimeInMs / 1000);\n\n      if (DEBUG_RENDERING_TRIANGLES_CENTER_DURING_ROTATION) {\n        const scalingNode = this.scalingNode.node as TransformNode;\n        const meshLine = MeshBuilder.CreateSphere(\n          `tr${this.mesh.getTriangle().getName()}`,\n          {\n            diameter: 0.1,\n          },\n        );\n        meshLine.parent = scalingNode;\n      }\n    } else if (amount >= 1) {\n      this.completeFlipping();\n    }\n\n    return this.nextState;\n  }\n\n  private getRotationSpeed(): number {\n    const rpm = 5;\n    const rotationSpeed = (rpm / 60) * Math.PI * 2;\n    return rotationSpeed;\n  }\n\n  private setupNodesOnFlipping(amount: number): void {\n    if (this.flipNode && this.scalingNode.node) {\n      this.flipNode.rotationQuaternion = Quaternion.RotationAxis(\n        this.rotation.axis,\n        Scalar.LerpAngle(0, this.rotation.angle, amount),\n      );\n      this.scalingNode.node.position = Vector3.Lerp(\n        this.scalingNode.originalPosition,\n        this.scalingNode.finalPosition,\n        amount,\n      );\n      this.scalingNode.node.rotation.y = Scalar.LerpAngle(\n        0,\n        -this.scalingNode.rotationAngle,\n        amount,\n      );\n    }\n  }\n\n  private setupBonesOnFlipping(amount: number): void {\n    const { bones, bonesDeformation, bonesScaling } = this.skeleton;\n    const rotationSpeed = this.getRotationSpeed();\n    const deltaTimeInMs = this.scene.getEngine().getDeltaTime();\n\n    if (bones && bonesDeformation && bonesScaling) {\n      bones.slice(0, 2).forEach((b, i) => {\n        const { rotation } = b;\n        rotation.y -= Scalar.Lerp(\n          0,\n          bonesDeformation[i],\n          rotationSpeed * (deltaTimeInMs / 1000),\n        );\n        b.setRotation(rotation);\n      });\n\n      const bonesScaleY = bonesScaling.map(\n        (boneScaling, i) =>\n          boneScaling &&\n          Scalar.Lerp(boneScaling.y, this.adjBonesScalingY[i], amount),\n      ) as number[];\n      if (bonesScaleY) {\n        this.skeleton.bonesIndices.forEach((boneIndex, i) => {\n          bones[boneIndex].setScale(\n            new Vector3(\n              bones[boneIndex].scaling.x,\n              bonesScaleY[i],\n              bones[boneIndex].scaling.z,\n            ),\n          );\n        });\n      }\n    }\n  }\n\n  private completeFlipping(): void {\n    this.nextState = new MeshStateIdle({\n      triangleMesh: this.mesh,\n      scene: this.scene,\n    });\n    if (this.onFlipEnd) {\n      this.onFlipEnd();\n    }\n  }\n}\nexport default MeshStateRotating;\n","import { Nullable, Scene } from '@babylonjs/core';\nimport TriangleMesh from '..';\nimport IMeshState from './IMeshState';\nimport MeshStateRotating from './MeshStateRotating';\n\nclass MeshStateIdle extends IMeshState {\n  private triangleMesh: TriangleMesh;\n\n  private nextState: Nullable<IMeshState> = null;\n\n  private scene: Scene;\n\n  public constructor({\n    triangleMesh,\n    scene,\n  }: {\n    triangleMesh: TriangleMesh;\n    scene: Scene;\n  }) {\n    super();\n    this.triangleMesh = triangleMesh;\n    this.scene = scene;\n  }\n\n  public update(\n    args: Nullable<{\n      direction?: number;\n      adjacentTriangleMesh?: Nullable<TriangleMesh>;\n      onFlipEnd?: () => void;\n    }> = null,\n  ): Nullable<IMeshState> {\n    if (args && args.adjacentTriangleMesh && args.direction) {\n      this.nextState = new MeshStateRotating({\n        thisTriangleMesh: this.triangleMesh,\n        adjacentTriangleMesh: args.adjacentTriangleMesh,\n        scene: this.scene,\n        direction: args.direction,\n        onFlipEnd: args.onFlipEnd,\n      });\n    }\n    return this.nextState;\n  }\n}\nexport default MeshStateIdle;\n","import Triangle, { Type } from 'models/Triangle';\nimport {\n  AbstractMesh,\n  Scene,\n  TransformNode,\n  Vector3,\n  StandardMaterial,\n  Nullable,\n  Quaternion,\n  Matrix,\n  MeshBuilder,\n} from '@babylonjs/core';\nimport { addAxisToScene, math } from 'utils';\nimport { k_triangleAssetName } from 'game-constants/identifiers';\nimport { k_epsilon, k_triangleScale } from 'game-constants';\nimport { DEBUG_RENDERING_ROTATION_NODE_ALIGNMENT } from 'game-constants/debug';\nimport EquilateralTriangleProvider from './EquilateralTriangleProvider';\nimport IMeshState from './State/IMeshState';\nimport MeshStateIdle from './State/MeshStateIdle';\n\nclass TriangleMesh {\n  private scene: Scene;\n\n  private triangle: Triangle;\n\n  private triangleMesh: Nullable<AbstractMesh>;\n\n  private triangleEdges: Nullable<Vector3[]> = null;\n\n  private triangleVertices: Nullable<Vector3[]> = null;\n\n  private equilateralTriangleRadius: number;\n\n  private scalingRatio: number;\n\n  private skeletonBonesScaling?: Vector3[];\n\n  private skeletonBonesRotation?: Vector3[];\n\n  private bonesRotationAngle: number[] = [];\n\n  private scalingNodeInitialPosition: Vector3 = Vector3.Zero();\n\n  private currentState: IMeshState;\n\n  public constructor({\n    scene,\n    triangle,\n    equilateralTriangleProvider,\n  }: {\n    scene: Scene;\n    triangle: Triangle;\n    equilateralTriangleProvider: EquilateralTriangleProvider;\n  }) {\n    this.currentState = new MeshStateIdle({ triangleMesh: this, scene });\n    this.triangle = triangle;\n    this.triangleMesh = null;\n    this.scene = scene;\n\n    const TRIANGLE_RADIUS = 1;\n    const TRIANGLE_SIDE = TRIANGLE_RADIUS * (3 / Math.sqrt(3));\n\n    const equilateralTriangle =\n      equilateralTriangleProvider.findEquilateralTriangle();\n\n    const triangleEdgeLength = equilateralTriangle\n      .p1()\n      .subtract(equilateralTriangle.p2())\n      .length();\n    this.scalingRatio =\n      (1 / TRIANGLE_SIDE) * triangleEdgeLength * k_triangleScale;\n\n    this.equilateralTriangleRadius = equilateralTriangle\n      .p1()\n      .subtract(equilateralTriangle?.getCenterPoint())\n      .length();\n    const mesh = scene.getMeshByName(k_triangleAssetName);\n\n    if (mesh) {\n      const triangleMesh = mesh.clone(triangle.getName(), mesh);\n      this.triangleMesh = triangleMesh;\n      if (triangleMesh) {\n        triangleMesh.metadata = { triangleMesh: this };\n\n        this.createNodesStructure(scene);\n\n        this.setupPosition(scene, this.scalingRatio);\n\n        triangleMesh.skeleton =\n          mesh &&\n          mesh.skeleton &&\n          mesh.skeleton.clone(`skeleton${triangle.getId()}`);\n\n        const angleBonesRotation = this.computeBonesRotationAngle({\n          triangle: this.triangle,\n        });\n\n        this.setAngleBonesRotation(angleBonesRotation);\n\n        const rotations = this.computeBonesDeformation();\n        const bonesScaleY = this.computeBonesScaling();\n\n        if (\n          this.triangleMesh &&\n          this.triangleMesh.skeleton &&\n          rotations &&\n          bonesScaleY\n        ) {\n          this.triangleMesh.skeleton.bones.forEach((bone, index) => {\n            bone.setRotation(rotations[index]);\n            bone.scale(1, bonesScaleY[index], 1);\n          });\n\n          this.skeletonBonesScaling = this.triangleMesh.skeleton.bones.map(\n            ({ scaling }) => new Vector3(scaling.x, scaling.y, scaling.z),\n          );\n          this.skeletonBonesRotation = this.triangleMesh.skeleton.bones.map(\n            ({ rotation }) => new Vector3(rotation.x, rotation.y, rotation.z),\n          );\n        }\n\n        this.setupMaterial();\n      }\n    }\n  }\n\n  private createNodesStructure(scene: Scene): void {\n    if (this.triangleMesh) {\n      const rootNode = scene.getNodeByName('root');\n      const positionNode = new TransformNode(\n        `positionNode${this.triangle.getId()}`,\n      );\n      positionNode.parent = rootNode;\n      const rotationNode = new TransformNode(\n        `rotationNode${this.triangle.getId()}`,\n      );\n      rotationNode.parent = positionNode;\n      const flipNode = new TransformNode(`flipNode${this.triangle.getId()}`);\n      flipNode.parent = rotationNode;\n      const scalingNode = new TransformNode(\n        `scalingNode${this.triangle.getId()}`,\n      );\n      flipNode.rotationQuaternion = Quaternion.Identity();\n\n      scalingNode.parent = flipNode;\n      this.triangleMesh.parent = scalingNode;\n      this.scalingNodeInitialPosition = scalingNode.position;\n    }\n  }\n\n  private setupPosition(scene: Scene, triangleMeshScalingRatio: number): void {\n    const positionNode = scene.getNodeByName(\n      `positionNode${this.triangle.getId()}`,\n    );\n    const rotationNode = scene.getNodeByName(\n      `rotationNode${this.triangle.getId()}`,\n    );\n    const scalingNode = scene.getNodeByName(\n      `scalingNode${this.triangle.getId()}`,\n    );\n\n    const triangleCenter = this.triangle.getCenterPoint();\n    const direction = triangleCenter; // Center - origin\n\n    const yawCorrection = 0;\n    const pitchCorrection = math.angle90;\n    const rollCorrection = 0;\n    if (positionNode && rotationNode && scalingNode && this.triangleMesh) {\n      (positionNode as TransformNode).setDirection(\n        direction,\n        yawCorrection,\n        pitchCorrection,\n        rollCorrection,\n      );\n      (rotationNode as TransformNode).position = new Vector3(\n        0,\n        direction.length(),\n        0,\n      );\n      (scalingNode as TransformNode).scaling = new Vector3(\n        triangleMeshScalingRatio,\n        triangleMeshScalingRatio,\n        triangleMeshScalingRatio,\n      );\n      const p1CenterVector = this.triangle.p1().subtract(triangleCenter);\n\n      const angle = Vector3.GetAngleBetweenVectors(\n        (rotationNode as TransformNode).forward,\n        p1CenterVector,\n        (rotationNode as TransformNode).up,\n      );\n\n      if (Math.abs(angle) > 0.05) {\n        (rotationNode as TransformNode).rotate(this.triangleMesh.up, angle);\n      } else if (DEBUG_RENDERING_ROTATION_NODE_ALIGNMENT) {\n        addAxisToScene({\n          scene,\n          size: 0.5,\n          parent: rotationNode as TransformNode,\n        });\n        MeshBuilder.CreateLines('line', {\n          points: [this.triangle.p1(), triangleCenter],\n        });\n      }\n    }\n  }\n\n  public computeBonesRotationAngle({\n    triangle,\n  }: {\n    triangle: Triangle;\n  }): number[] {\n    const triangleCenter = triangle.getCenterPoint();\n    const p1CenterVector = triangle.p1().subtract(triangleCenter);\n    const p2CenterVector = triangle.p2().subtract(triangleCenter);\n    const p3CenterVector = triangle.p3().subtract(triangleCenter);\n\n    const positionNode = this.scene.getNodeByName(\n      `positionNode${this.getTriangle().getId()}`,\n    );\n\n    if (positionNode) {\n      const angleP1ToP3 = Vector3.GetAngleBetweenVectors(\n        p1CenterVector,\n        p3CenterVector,\n        (positionNode as TransformNode).up,\n      );\n      const angleP1ToP2 = Vector3.GetAngleBetweenVectors(\n        p1CenterVector,\n        p2CenterVector,\n        (positionNode as TransformNode).up,\n      );\n      const deltaAngle1 = angleP1ToP3 - math.angle120;\n      const deltaAngle2 = angleP1ToP2 + math.angle120;\n\n      return [deltaAngle1, deltaAngle2, 0];\n    }\n    return [0, 0, 0];\n  }\n\n  public setAngleBonesRotation(rotations: number[]): void {\n    this.bonesRotationAngle = rotations;\n  }\n\n  public computeBonesDeformation(): Vector3[] {\n    // eslint-disable-next-line no-console\n    console.assert(\n      this.triangleMesh && this.triangleMesh.skeleton,\n      'Mesh and skeleton must exist',\n    );\n    if (this.triangleMesh && this.triangleMesh.skeleton) {\n      const skeletonMesh = this.triangleMesh.skeleton;\n\n      const bone1rotation = skeletonMesh.bones[0].rotation.clone();\n      const bone2rotation = skeletonMesh.bones[1].rotation.clone();\n      const bone3rotation = skeletonMesh.bones[2].rotation.clone();\n\n      bone1rotation.y += this.bonesRotationAngle[0];\n      bone2rotation.y += this.bonesRotationAngle[1];\n\n      return [bone1rotation, bone2rotation, bone3rotation];\n    }\n    return [Vector3.Zero(), Vector3.Zero(), Vector3.Zero()];\n  }\n\n  public computeBonesScaling(): number[] {\n    const triangleCenter = this.triangle.getCenterPoint();\n    const p1CenterVector = this.triangle.p1().subtract(triangleCenter);\n    const p2CenterVector = this.triangle.p2().subtract(triangleCenter);\n    const p3CenterVector = this.triangle.p3().subtract(triangleCenter);\n    if (\n      this.triangleMesh &&\n      this.triangleMesh.skeleton &&\n      this.equilateralTriangleRadius\n    ) {\n      const scaleBones = [\n        p3CenterVector.length() / this.equilateralTriangleRadius,\n        p2CenterVector.length() / this.equilateralTriangleRadius,\n        p1CenterVector.length() / this.equilateralTriangleRadius,\n      ];\n\n      return scaleBones;\n    }\n    return [1, 1, 1];\n  }\n\n  public setupMaterial(): void {\n    if (this.triangleMesh) {\n      const material = new StandardMaterial(\n        `meshMaterial${this.triangle.getId()}`,\n        this.scene,\n      );\n      material.diffuseColor = this.triangle.getColor();\n      material.backFaceCulling = false;\n      material.alpha = 1;\n      this.triangleMesh.material = material;\n    }\n  }\n\n  public getTriangle(): Triangle {\n    return this.triangle;\n  }\n\n  public getTriangleMesh(): Nullable<AbstractMesh> {\n    return this.triangleMesh;\n  }\n\n  public getVertices(): Nullable<Vector3[]> {\n    return this.triangleVertices;\n  }\n\n  public setVertices(vertices: Vector3[]): void {\n    this.triangleVertices = vertices;\n  }\n\n  public getEdges(): Nullable<Vector3[]> {\n    return this.triangleEdges;\n  }\n\n  public setEdges(edges: Vector3[]): void {\n    this.triangleEdges = edges;\n  }\n\n  public getScalingRatio(): number {\n    return this.scalingRatio;\n  }\n\n  public flip({\n    triangleMesh,\n    direction,\n    onFlipEnd,\n  }: {\n    triangleMesh: TriangleMesh;\n    direction: number;\n    onFlipEnd?: () => void;\n  }): void {\n    const context = {\n      adjacentTriangleMesh: triangleMesh,\n      direction,\n      onFlipEnd,\n    };\n    this.update(context);\n  }\n\n  public update(context?: {\n    adjacentTriangleMesh: TriangleMesh;\n    direction: number;\n    onFlipEnd?: () => void;\n  }): void {\n    const nextState = this.currentState.update(context);\n\n    if (nextState) {\n      this.currentState = nextState;\n    }\n  }\n\n  public computeObjSpaceVertices(): Vector3[] | undefined {\n    if (this.triangle && this.triangleMesh) {\n      const tr = this.triangle;\n      const matrix = this.triangleMesh.computeWorldMatrix(true);\n      const vertices = [\n        Vector3.TransformCoordinates(tr.p1(), Matrix.Invert(matrix)),\n        Vector3.TransformCoordinates(tr.p2(), Matrix.Invert(matrix)),\n        Vector3.TransformCoordinates(tr.p3(), Matrix.Invert(matrix)),\n      ];\n\n      return vertices;\n    }\n    // eslint-disable-next-line no-console\n    console.assert(this.triangleMesh && this.triangle, 'Asset not found');\n    return undefined;\n  }\n\n  public computeObjSpaceEdges(vertices: Vector3[]): Vector3[] {\n    const edges = vertices.map((v, i) =>\n      v.subtract(vertices[(i + 1) % vertices.length]),\n    );\n    return edges;\n  }\n\n  public getAdjacentsVerticesMap(\n    adjTriangle: Triangle,\n  ): Record<string, number[]> {\n    const trVertices = this.triangle.getVertices();\n    const adjTrVertices = adjTriangle.getVertices();\n    const adjacentsMap: Record<string, number[]> = {\n      trAdjs: [],\n      adjTrAdjs: [],\n    };\n    if (trVertices && adjTrVertices) {\n      trVertices.forEach((trVertice: Vector3, indexTrVertice: number) => {\n        adjTrVertices.forEach(\n          (adjTrVertice: Vector3, indexAdjTrVertice: number) => {\n            if (adjTrVertice.subtract(trVertice).length() < k_epsilon) {\n              adjacentsMap.trAdjs.push(indexTrVertice);\n              adjacentsMap.adjTrAdjs.push(indexAdjTrVertice);\n            }\n          },\n        );\n      });\n    }\n    return adjacentsMap;\n  }\n\n  public getTriangleMeshBonesIndices(verticeIndices: number[]): number[] {\n    const bonesIndices: number[] = [];\n    verticeIndices.forEach((k, i) => {\n      switch (k) {\n        case 0:\n          bonesIndices[i] = 2;\n          break;\n        case 1:\n          bonesIndices[i] = 1;\n          break;\n        case 2:\n          bonesIndices[i] = 0;\n          break;\n        default:\n      }\n    });\n    return bonesIndices;\n  }\n\n  public getTriangleMeshIndicesSum(verticeIndices: number[]): number {\n    return verticeIndices.reduce((curr, prev) => curr + prev);\n  }\n\n  public getTriangleMeshFlipEdgeIndex(indicesSum: number): number {\n    switch (indicesSum) {\n      case 1:\n        return 0;\n      case 2:\n        return 2;\n      case 3:\n        return 1;\n      default:\n    }\n    // eslint-disable-next-line no-console\n    console.assert(true, 'return value should be a number beetwen 0 and 2');\n    return -1;\n  }\n\n  public getAngleBonesRotation(): number[] {\n    return this.bonesRotationAngle;\n  }\n\n  public reset(type: Type): void {\n    const mesh = this.triangleMesh;\n    if (mesh && mesh.skeleton) {\n      mesh.skeleton.bones.forEach((b, i) => {\n        if (this.skeletonBonesScaling) {\n          b.setScale(this.skeletonBonesScaling[i]);\n        }\n        if (this.skeletonBonesRotation) {\n          b.setRotation(this.skeletonBonesRotation[i]);\n        }\n      });\n    }\n    const scalingNode = mesh?.parent as TransformNode;\n    const flipNode = scalingNode.parent as TransformNode;\n    scalingNode.position = this.scalingNodeInitialPosition;\n    scalingNode.rotation.y = 0;\n    flipNode.position = this.scalingNodeInitialPosition;\n    flipNode.rotationQuaternion = new Quaternion(0, 0, 0, 1);\n\n    this.triangle.setType(type);\n    this.setupMaterial();\n  }\n}\n\nexport default TriangleMesh;\n","import { Vector3 } from '@babylonjs/core';\nimport { TriangleEdge } from 'models/Triangle';\nimport IIcosahedronDeserializer, {\n  Icosahedron,\n  Triangle,\n  Triangles,\n  ISubdivisionStrategy,\n} from './IIcosahedronDeserializer';\n\ninterface AdjacentJSON {\n  triangleId: number;\n}\ninterface VertexJSON {\n  _x: number;\n  _y: number;\n  _z: number;\n}\n\ninterface TriangleJson {\n  triangleId: bigint;\n  vertices: Array<VertexJSON>;\n  type: number;\n  adjacents: Array<AdjacentJSON>;\n}\n\nclass JsonIcosahedronDeserializer implements IIcosahedronDeserializer {\n  private version = '1.0.0';\n\n  public deserialize(\n    descriptor: string,\n    subdivisionStrategy: ISubdivisionStrategy,\n  ): Icosahedron {\n    const parsed = JSON.parse(descriptor, (key, value) => {\n      if (key === 'jsonSerializerVersion') {\n        // eslint-disable-next-line no-console\n        console.assert(\n          this.version === value,\n          'Mismatching serializer/deserializer versions',\n        );\n      }\n      return value;\n    });\n    const jsonTriangleMap = parsed.triangles.reduce(\n      (prev: any, curr: { triangleId: any }) => {\n        const id = `${curr.triangleId}`;\n        return { ...prev, [id]: curr };\n      },\n      {},\n    );\n    const triangles = parsed.triangles.map((triangle: TriangleJson) => {\n      const { triangleId, vertices, type } = triangle;\n      // eslint-disable-next-line no-underscore-dangle\n      const p1 = new Vector3(vertices[0]._x, vertices[0]._y, vertices[0]._z);\n      // eslint-disable-next-line no-underscore-dangle\n      const p2 = new Vector3(vertices[1]._x, vertices[1]._y, vertices[1]._z);\n      // eslint-disable-next-line no-underscore-dangle\n      const p3 = new Vector3(vertices[2]._x, vertices[2]._y, vertices[2]._z);\n\n      return new Triangle(triangleId, p1, p2, p3, type);\n    });\n    const triangleMap = triangles.reduce(\n      (prev: any, curr: { getId: () => bigint }) => {\n        const id = `${curr.getId()}`;\n        return { ...prev, [id]: curr };\n      },\n      {},\n    );\n    triangles.forEach((tr: Triangle) => {\n      const id = `${tr.getId()}`;\n      jsonTriangleMap[id].adjacents.forEach(\n        (adj: { triangleId: number }, idx: TriangleEdge) => {\n          tr.setAdjacent(triangleMap[`${adj.triangleId}`], idx);\n        },\n      );\n      return tr;\n    });\n    return new Icosahedron({\n      triangles,\n      subdivisionStrategy,\n    });\n  }\n}\nexport default JsonIcosahedronDeserializer;\n","import { Vector3 } from '@babylonjs/core';\nimport { k_epsilon } from 'game-constants/index';\nimport Triangle from 'models/Triangle';\n\nexport const isDuplicated = (\n  triangles: Triangle[],\n  triangle: Triangle,\n): boolean => !!triangles.find((e) => e.getId() === triangle.getId());\n\nexport const hasPoint = (tr: Triangle, point: Vector3): boolean =>\n  !!tr.getVertices().find((p) => p.subtract(point).length() < k_epsilon);\n\nexport const haveSameType = (tr1: Triangle, tr2: Triangle): boolean =>\n  tr1.getType() === tr2.getType();\n","import { Vector3 } from '@babylonjs/core';\nimport { Nullable } from '@babylonjs/core/types';\nimport Triangle from 'models/Triangle';\nimport { isDuplicated, hasPoint, haveSameType } from 'gameplay/utils';\n\nexport type Hexagon = Triangle[];\nexport type Hexagons = Hexagon[];\n\nexport const shapesVerify = (triangles: Triangle[]): Hexagons => {\n  const shapes: Hexagons = [];\n  triangles.forEach((tr) => {\n    const shapesList = [\n      { pivotPoint: tr.p1(), adjsPivotPoint: getAdjacentsToPoint(tr, 1) },\n      { pivotPoint: tr.p2(), adjsPivotPoint: getAdjacentsToPoint(tr, 2) },\n      { pivotPoint: tr.p3(), adjsPivotPoint: getAdjacentsToPoint(tr, 0) },\n    ]\n      .map(({ pivotPoint, adjsPivotPoint }) =>\n        findHexagon(tr, pivotPoint, adjsPivotPoint),\n      )\n      .filter((hex) => !!hex) as Hexagons;\n    shapesList.forEach((hex: Hexagon) => shapes.push(hex));\n  });\n\n  return shapes;\n};\n\nconst findHexagon = (\n  tr: Triangle,\n  point: Vector3,\n  adjs: Triangle[],\n): Nullable<Hexagon> => {\n  const shape: Triangle[] = [tr];\n  if (\n    adjs[0] &&\n    adjs[1] &&\n    haveSameType(tr, adjs[0]) &&\n    haveSameType(tr, adjs[1])\n  ) {\n    shape.push(adjs[0]);\n    shape.push(adjs[1]);\n    adjs.forEach((adj) => {\n      const adjs2 = adj\n        ?.getAdjacents()\n        .find(\n          (adj2) =>\n            adj2?.getType() === tr.getType() &&\n            adj2.getId() !== tr.getId() &&\n            hasPoint(adj2, point),\n        );\n\n      if (adjs2) {\n        if (!isDuplicated(shape, adjs2)) {\n          shape.push(adjs2);\n        }\n\n        if (adj && hasPoint(adjs2, point)) {\n          const adjs3 = adjs2\n            ?.getAdjacents()\n            .find(\n              (adj3) =>\n                adj3?.getType() === tr.getType() &&\n                adj3.getId() !== adj.getId() &&\n                hasPoint(adj3, point),\n            );\n\n          if (adjs3 && hasPoint(adjs3, point)) {\n            if (!isDuplicated(shape, adjs3)) {\n              shape.push(adjs3);\n            }\n          }\n        }\n      }\n    });\n  }\n  if (shape.length === 6) {\n    const hexagon = shape as Hexagon;\n    return hexagon;\n  }\n\n  return null;\n};\n\nconst getAdjacentsToPoint = (tr: Triangle, index: number): Triangle[] =>\n  tr.getAdjacents().filter((a, i) => i !== index) as Triangle[];\n","import { ArcRotateCamera, Vector3, Scene } from '@babylonjs/core';\n\nconst setupCamera = (scene: Scene, target: Vector3): ArcRotateCamera => {\n  const alpha = -Math.PI * 0.5;\n  const beta = Math.PI * 0.4;\n  const radius = 3;\n  const camera = new ArcRotateCamera(\n    'camera',\n    alpha,\n    beta,\n    radius,\n    target,\n    scene,\n  );\n  camera.minZ = 0.1;\n  camera.lowerRadiusLimit = 1.5; // we dont' want to get too close\n  return camera;\n};\n\nexport default setupCamera;\n","import { Scene, HemisphericLight, Vector3 } from '@babylonjs/core';\n\nconst setupLight = (scene: Scene, target: Vector3): void => {\n  const light = new HemisphericLight('light', new Vector3(0, 1, 0), scene);\n  light.intensity = 1.1;\n  light.setDirectionToTarget(target);\n  // light.parent = camera;\n};\n\nexport default setupLight;\n","import {\n  TransformNode,\n  Vector3,\n  Scene,\n  Mesh,\n  StandardMaterial,\n  VertexData,\n  Color3,\n  MeshBuilder,\n  PointerEventTypes,\n} from '@babylonjs/core';\nimport {\n  DEBUG_RENDERING_ADJACENTS,\n  DEBUG_RENDERING_ALL_TRIANGLES_CENTER,\n} from 'game-constants/debug';\n\nimport Triangle, { TriangleId } from 'models/Triangle';\n\nconst getMeshName = (triangleId: TriangleId): string => {\n  const meshName = `Input${triangleId}`;\n  return meshName;\n};\n\nconst generateInputMesh = (\n  name: string,\n  scene: Scene,\n  triangles: Array<Triangle>,\n  renderNormals = false,\n): void => {\n  //\n  const rootNode = new TransformNode(name, scene);\n\n  triangles.forEach((triangle) => {\n    if (DEBUG_RENDERING_ALL_TRIANGLES_CENTER) {\n      const line = MeshBuilder.CreateLines(`tr${triangle.getName()}`, {\n        points: [\n          triangle.getCenterPoint().scale(1.05),\n          triangle.getCenterPoint(),\n        ],\n      });\n      line.color = new Color3(0, 0, 0);\n    }\n\n    const vertexData = createVertexData(triangle, renderNormals);\n    const meshName = getMeshName(triangle.getId());\n    const mesh = createMesh(meshName, scene, vertexData);\n    mesh.parent = rootNode;\n    mesh.metadata = { triangle };\n  });\n\n  if (DEBUG_RENDERING_ADJACENTS) {\n    scene.onPointerObservable.add((pointerInfo) => {\n      switch (pointerInfo.type) {\n        case PointerEventTypes.POINTERDOWN:\n          {\n            const mesh =\n              pointerInfo?.pickInfo?.hit && pointerInfo.pickInfo.pickedMesh;\n            const metadata = mesh && mesh.metadata;\n            if (metadata) {\n              const { triangle } = metadata;\n              const adjacentIds: Array<TriangleId> = triangle\n                .getAdjacents()\n                .map((tr: Triangle) => tr?.getId() || -1);\n\n              adjacentIds.forEach((adjId) => {\n                const adjMesh = scene.getMeshByName(getMeshName(adjId));\n\n                if (adjMesh && adjMesh.material) {\n                  adjMesh.material.alpha = 0.5;\n                  const mat: StandardMaterial =\n                    adjMesh.material as StandardMaterial;\n                  mat.diffuseColor = new Color3(0, 0, 0);\n                }\n              });\n            }\n          }\n\n          break;\n        default:\n          break;\n      }\n    });\n  }\n};\n\nconst createVertexData = (triangle: Triangle, renderNormals: boolean) => {\n  const normals: Array<number> = [];\n  const indices: Array<number> = [0, 1, 2];\n  const positions = triangle\n    .getVertices()\n    .reduce(\n      (prev: number[], curr: Vector3): number[] => [\n        ...prev,\n        curr.x,\n        curr.y,\n        curr.z,\n      ],\n      [],\n    );\n  const vertexData = new VertexData();\n  VertexData.ComputeNormals(positions, indices, normals);\n\n  vertexData.positions = positions;\n  vertexData.indices = indices;\n  vertexData.normals = normals;\n\n  if (renderNormals) {\n    // Setup to debugging triangles face direction\n    {\n      const options = {\n        points: [\n          triangle.p1(),\n          triangle.p1().add(new Vector3(normals[0], normals[1], normals[2])),\n        ],\n        updatable: true,\n      };\n      const lines = MeshBuilder.CreateLines('lines', options);\n      lines.color = new Color3(1, 0, 0);\n    }\n    {\n      const options = {\n        points: [\n          triangle.p2(),\n          triangle.p2().add(new Vector3(normals[3], normals[4], normals[5])),\n        ],\n        updatable: true,\n      };\n      const lines = MeshBuilder.CreateLines('lines', options);\n      lines.color = new Color3(1, 0, 0);\n    }\n    {\n      const options = {\n        points: [\n          triangle.p3(),\n          triangle.p3().add(new Vector3(normals[6], normals[7], normals[8])),\n        ],\n        updatable: true,\n      };\n      const lines = MeshBuilder.CreateLines('lines', options);\n      lines.color = new Color3(1, 0, 0);\n    }\n  }\n\n  return vertexData;\n};\n\nconst createMesh = (\n  name: string,\n  scene: Scene,\n  vertexData: VertexData,\n): Mesh => {\n  const customMesh = new Mesh(name, scene);\n  customMesh.isPickable = true;\n  const material = new StandardMaterial('myMaterial', scene);\n  const hue = Math.random() * 255;\n  const saturation = 1;\n  const value = 1;\n  Color3.HSVtoRGBToRef(hue, saturation, value, material.diffuseColor);\n  material.backFaceCulling = false;\n  material.alpha = 0;\n  customMesh.material = material;\n  vertexData.applyToMesh(customMesh, true);\n  return customMesh;\n};\n\nexport default generateInputMesh;\n","import { ArcRotateCamera, Scene } from '@babylonjs/core';\nimport Triangle from 'models/Triangle';\nimport generateInputMesh from './generateInputMesh';\n\nconst setupInput = (\n  scene: Scene,\n  camera: ArcRotateCamera,\n  triangles: Triangle[],\n): void => {\n  const canvas = scene.getEngine().getRenderingCanvas();\n  camera.attachControl(canvas, true);\n  generateInputMesh('icosahedron', scene, triangles);\n};\n\nexport default setupInput;\n","import {\n  Scene,\n  PointerEventTypes,\n  ArcRotateCamera,\n  AbstractMesh,\n} from '@babylonjs/core';\n\nimport Triangle from 'models/Triangle';\nimport Gesture, { GestureId } from './Gesture';\nimport FlipGesture from './FlipGesture';\nimport setupInput from './setupInput';\n\nclass InputManager {\n  //\n  private scene: Scene;\n\n  private gesturesMap: Record<GestureId, Gesture> = {};\n\n  public constructor(\n    scene: Scene,\n    camera: ArcRotateCamera,\n    triangles: Triangle[],\n  ) {\n    this.scene = scene;\n    setupInput(scene, camera, triangles);\n  }\n\n  public onMeshLoaded(triangleMesh: AbstractMesh): void {\n    this.scene.onPointerObservable.add((pointerInfo) => {\n      const { pointerId } = pointerInfo.event;\n      switch (pointerInfo.type) {\n        case PointerEventTypes.POINTERDOWN:\n        case PointerEventTypes.POINTERTAP:\n          {\n            const mesh =\n              pointerInfo?.pickInfo?.hit && pointerInfo.pickInfo.pickedMesh;\n            if (mesh) {\n              const gestureContext = {\n                scene: this.scene,\n                triangleMesh,\n                onFlipEnded: () => {\n                  delete this.gesturesMap[pointerId];\n                },\n              };\n              this.gesturesMap[pointerId] = new FlipGesture(gestureContext);\n              this.gesturesMap[pointerId].onDown(pointerInfo);\n            }\n          }\n          break;\n\n        case PointerEventTypes.POINTERMOVE:\n          {\n            let gesture = this.gesturesMap[pointerId];\n            if (!gesture) {\n              const gestureContext = {\n                scene: this.scene,\n                triangleMesh,\n                onFlipEnded: () => {\n                  delete this.gesturesMap[pointerId];\n                },\n              };\n              gesture = new FlipGesture(gestureContext);\n              this.gesturesMap[pointerId] = gesture;\n            }\n\n            gesture.onMove(pointerInfo);\n          }\n          break;\n        case PointerEventTypes.POINTERUP:\n          {\n            const gesture = this.gesturesMap[pointerId];\n            if (gesture) {\n              gesture.onRelease(pointerInfo);\n            }\n            delete this.gesturesMap[pointerId];\n          }\n          break;\n        default:\n          break;\n      }\n    });\n  }\n}\n\nexport default InputManager;\n","import {\n  Vector3,\n  Scene,\n  SceneLoader,\n  ArcRotateCameraPointersInput,\n} from '@babylonjs/core';\nimport {\n  k_triangleAssetName,\n  k_triangleAssetDebugFileName,\n  k_triangleAssetPath,\n} from 'game-constants/identifiers';\nimport Icosahedron from 'models/Icosahedron';\nimport _1to4SubdivisionStrategy from 'models/Icosahedron/SubdivisionStrategy/1to4SubdivisionStrategy';\nimport TriangleMesh from 'rendering/TriangleMesh/index';\nimport JsonIcosahedronDeserializer from 'deserializers/JsonIcosahedronDeserializer';\n// import JsonIcosahedronSerializer from 'serializers/JsonIcosahedronSerializer'; // #Serialization\nimport {\n  shapesVerify,\n  Hexagon,\n  Hexagons,\n} from 'gameplay/ShapeDetector/shapesVerify';\nimport Triangle from 'models/Triangle';\nimport setupCamera from 'components/GameComponent/setupCamera';\nimport setupLight from 'components/GameComponent/setupLight';\nimport InputManager from 'components/GameComponent/InputManager';\nimport { DEBUG_RENDERING_ADJS_TRIANGLES_BY_ID } from 'game-constants/debug';\nimport { adjsTrianglesDebug } from 'utils';\n\nconst useGameLogic = (): {\n  onRender: (scene: Scene) => void;\n  onSceneReady: (sceneArg: Scene) => void;\n} => {\n  const loadIcosahedron = async () => {\n    const subdivisionStrategy = new _1to4SubdivisionStrategy();\n    try {\n      const json = await fetch('assets/data/icosahedron-0.json').then(\n        (response) => response.text(),\n      );\n      if (json && json.length) {\n        // eslint-disable-next-line no-console\n        console.log('Icosahedron JSON file loaded.');\n        const deserializer = new JsonIcosahedronDeserializer();\n        return deserializer.deserialize(json, subdivisionStrategy);\n      }\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.log('Icosahedron JSON file was not found.');\n    }\n    const icosahedron = new Icosahedron({ subdivisionStrategy });\n    icosahedron.subdivide(2);\n    // #Serialization\n    // const serializer = new JsonIcosahedronSerializer();\n    // const json = serializer.serialize(icosahedron);\n    // eslint-disable-next-line no-console\n    // console.log('Icosahedron json', json);\n    return icosahedron;\n  };\n\n  const onSceneReady = async (sceneArg: Scene) => {\n    const scene: Scene = sceneArg;\n    const target = new Vector3(0, 0, 0);\n    const camera = setupCamera(scene, target);\n    (camera.inputs.attached.pointers as ArcRotateCameraPointersInput).buttons =\n      [1];\n    const icosahedron = await loadIcosahedron();\n    // console.log('Icosahedron loaded');\n    icosahedron.registerOnTriangleChanged((triangles) => {\n      const hexagons: Hexagons = shapesVerify(triangles);\n\n      if (hexagons) {\n        hexagons.forEach((hex: Hexagon) => {\n          if (hex) {\n            hex.forEach((tr) => {\n              const mesh = scene.getMeshByName(tr.getName());\n              const trMesh = mesh && mesh.metadata.triangleMesh;\n              trMesh.reset(Triangle.getRandomType());\n            });\n          }\n        });\n      }\n    });\n\n    const triangles = icosahedron.getTriangles();\n\n    scene.metadata = { icosahedron };\n\n    const inputManager = new InputManager(scene, camera, triangles);\n    setupLight(scene, target);\n\n    SceneLoader.ImportMeshAsync(\n      k_triangleAssetName,\n      k_triangleAssetPath,\n      k_triangleAssetDebugFileName,\n    ).then(({ meshes, skeletons }) => {\n      if (meshes && meshes.length > 0 && skeletons) {\n        const assetMesh = meshes[0];\n\n        const trianglesMeshesToRender = DEBUG_RENDERING_ADJS_TRIANGLES_BY_ID\n          ? adjsTrianglesDebug(triangles, 361)\n          : triangles;\n\n        const triangleMeshes = trianglesMeshesToRender.map(\n          (tr) =>\n            new TriangleMesh({\n              scene,\n              triangle: tr,\n              equilateralTriangleProvider: icosahedron,\n            }),\n        );\n        assetMesh.visibility = 0;\n\n        scene.registerBeforeRender(() => {\n          triangleMeshes.forEach((t) => t.update());\n        });\n\n        inputManager.onMeshLoaded(assetMesh);\n      }\n    });\n  };\n\n  const onRender = (scene: Scene) => {\n    const root = scene.getTransformNodeByName('root');\n    if (root) {\n      // const deltaTimeInMillis = scene.getEngine().getDeltaTime();\n      // const rpm = 5;\n      // root.rotation.y += (rpm / 60) * Math.PI * 2 * (deltaTimeInMillis / 1000);\n    }\n  };\n\n  return { onRender, onSceneReady };\n};\n\nexport default useGameLogic;\n","import { Engine, EngineOptions, Scene, SceneOptions } from '@babylonjs/core';\n// fixme: enable this import only on debug\nimport '@babylonjs/inspector';\nimport { DEBUG_RENDERING_WORLD_AXIS } from 'game-constants/debug';\n\nimport React, { useEffect, useRef } from 'react';\nimport { addAxisToScene } from 'utils';\n\ntype onRenderCallback = (a: Scene) => void;\ntype onSceneReadyCallback = (a: Scene) => void;\n\ninterface SceneComponentProps {\n  antialias?: boolean;\n  engineOptions?: EngineOptions;\n  adaptToDeviceRatio?: boolean;\n  sceneOptions?: SceneOptions;\n  onRender: onRenderCallback;\n  onSceneReady: onSceneReadyCallback;\n}\n\nconst SceneComponent: React.FC<SceneComponentProps> = (props) => {\n  const reactCanvas = useRef(null);\n  const {\n    antialias,\n    engineOptions,\n    adaptToDeviceRatio,\n    sceneOptions,\n    //\n    onRender,\n    onSceneReady,\n    ...rest\n  } = props;\n\n  useEffect(() => {\n    if (reactCanvas.current) {\n      const engine = new Engine(\n        reactCanvas.current,\n        antialias,\n        engineOptions,\n        adaptToDeviceRatio,\n      );\n      const scene = new Scene(engine, sceneOptions);\n      if (scene.isReady()) {\n        onSceneReady(scene);\n      } else {\n        scene.onReadyObservable.addOnce((observedScene) =>\n          onSceneReady(observedScene),\n        );\n      }\n\n      engine.runRenderLoop(() => {\n        if (typeof onRender === 'function') {\n          onRender(scene);\n        }\n        scene.render();\n      });\n\n      const resize = () => {\n        scene.getEngine().resize();\n      };\n\n      if (window) {\n        window.addEventListener('resize', resize);\n      }\n\n      if (DEBUG_RENDERING_WORLD_AXIS) {\n        scene.debugLayer.show();\n        // WORLD AXIS\n        addAxisToScene({ scene, size: 5 });\n      }\n\n      return () => {\n        scene.getEngine().dispose();\n\n        if (window) {\n          window.removeEventListener('resize', resize);\n        }\n      };\n    }\n    return undefined;\n  }, [reactCanvas]);\n\n  return (\n    <canvas\n      ref={reactCanvas}\n      width={window.innerWidth}\n      height={window.innerHeight}\n      {...rest}\n    />\n  );\n};\nexport default SceneComponent;\n","import React from 'react';\nimport useGameLogic from 'gameplay/game/useGameLogic';\nimport SceneComponent from 'components/SceneComponent';\n\nconst GameComponent: React.FC = () => {\n  const { onRender, onSceneReady } = useGameLogic();\n  return (\n    <SceneComponent antialias onSceneReady={onSceneReady} onRender={onRender} />\n  );\n};\n\nexport default GameComponent;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import App from './App';\nimport { Route, BrowserRouter, Routes } from 'react-router-dom';\nimport GameComponent from './components/GameComponent/index';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <BrowserRouter basename=\"/xagon-js\">\n      <Routes>\n        <Route path=\"/\" element={<GameComponent />} />\n      </Routes>\n    </BrowserRouter>\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}