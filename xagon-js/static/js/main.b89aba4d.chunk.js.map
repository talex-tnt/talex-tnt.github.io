{"version":3,"sources":["models/Triangle.ts","game-constants/identifiers.ts","game-constants/index.ts","rendering/TriangleMesh/EquilateralTriangleProvider.ts","models/Icosahedron/index.ts","components/GameComponent/InputManager/FlipGesture.ts","models/Icosahedron/SubdivisionStrategy/1to4SubdivisionStrategy.ts","utils/math.ts","rendering/TriangleMesh/State/IMeshState.ts","components/GameComponent/InputManager/Gesture.ts","utils/scene.ts","rendering/TriangleMesh/State/MeshStateRotating.ts","rendering/TriangleMesh/State/MeshStateIdle.ts","rendering/TriangleMesh/index.ts","deserializers/JsonIcosahedronDeserializer.ts","gameplay/utils/index.ts","gameplay/ShapeDetector/shapesVerify.ts","components/GameComponent/setupCamera.tsx","components/GameComponent/setupLight.tsx","components/GameComponent/InputManager/setupInput/generateInputMesh.tsx","components/GameComponent/InputManager/setupInput/index.tsx","components/GameComponent/InputManager/index.tsx","gameplay/game/useGameLogic.ts","components/SceneComponent.tsx","components/GameComponent/index.tsx","reportWebVitals.ts","index.tsx"],"names":["TriangleEdge","Type","k_triangleAssetName","k_epsilon","EquilateralTriangleProvider","colors","First","Color3","Blue","Second","Red","Third","Yellow","Fourth","Green","Fifth","Purple","Sixth","Gray","typesCount","Object","keys","length","Triangle","id","p1","p2","p3","type","getRandomType","vertices","triangleId","adjacents","this","getId","middlePoint1","Vector3","Center","center1","add","subtract","scale","middlePoint2","center2","middlePoint3","center3","middlePoint","triangle","index","console","assert","find","tr","push","isAdjacent","adj","Math","floor","random","getTypesCount","Icosahedron","context","triangles","triangleCount","subdivisionStrategy","onTrianglesChanged","computeRegularIcosahedronTriangles","computeAdjacentTriangles","genTriangleId","b","sqrt","points","map","Normalize","indices","count","i","subdivide","onTriangleChanged","changes","equilateralTriangle","edgeLength1","toFixed","edgeLength2","edgeLength3","warn","findPointIndex","point","getVertices","findIndex","trPoint","abs","forEach","tr1","tr2","adjacentIndices","filter","indicesSum","setAdjacent","Direction","_1to4SubdivisionStrategy","icosahedron","getTriangles","reduce","prev","curr","subdivideTriangle","subTriangles","makeTriangle","setType","angle90","PI","angle120","IMeshState","Gesture","FlipGesture","firstTriangleMesh","secondTriangleMesh","startPoint","Vector2","Zero","lastEventTimestamp","pointerInfo","mesh","pickInfo","hit","pickedMesh","event","x","y","Date","now","getTriangleMesh","pickinfo","scene","pick","pointerX","pointerY","log","JSON","stringify","pressure","firstTriangle","getTriangle","finalPoint","metadata","assetMesh","assetMeshID","getAdjacents","a","secondTriangle","flipEnded","swapType","trM1","trM2","tr1Type","getType","tr2Type","reset","notifyTrianglesChanged","flip","triangleMesh","direction","Up","onFlipEnd","onFlipEnded","Down","originalMesh","name","getName","getMeshByName","getAssetMesh","computeObjSpaceVertices","scalingRatio","getScalingRatio","scaledVertices","v","edges","computeObjSpaceEdges","setVertices","setEdges","MeshStateRotating","thisTriangleMesh","adjacentTriangleMesh","nextState","adjacentMesh","rotation","axis","angle","flipNode","scalingNode","node","originalPosition","finalPosition","rotationAngle","skeleton","bones","bonesScaling","bonesIndices","bonesDeformation","adjBonesScalingY","amount","adjacentsVerticesMap","getAdjacentsVerticesMap","trMesh","parent","thisTriangleAdjVertIndices","trAdjs","computeRotationAxis","computeFlipNodePosition","rotationData","computeRotationData","rotationDownAngle","scalingNodeShiftRatio","adjRotationVector","rotationVector","centerShiftVector","computeCenterShiftVector","position","clone","getBonesIndices","getBonesScaling","adjTriangleAdjVertIndices","adjTrAdjs","computeAdjBonesScalingY","adjTriangleNotAdjVertexIndex","e","adjTriangleVertIndex","computeNodeRotationAngleToVertex","computeBonesDeformation","vertIndices","vertIndicesSum","getTriangleMeshIndicesSum","edgeIndex","getTriangleMeshFlipEdgeIndex","getEdges","flipNodeCenter","edgeCenterPoint","setPositionWithLocalVector","worldSpaceVertices","triangleMeshMatrix","computeWorldMatrix","centerADJ","TransformCoordinates","getCenterPoint","Matrix","Invert","point1","computeVectorProjectionPoint","index1","index2","point2","center","vectorCenterPoint","adjVectorCenterPoint","normal","Cross","GetAngleBetweenVectors","worldSpaceAdjEdgeCenterPoint","worldSpaceAdjEdge","projectionAngle","scalarProjection","cos","verticesMap","adjVertices","adjVertIndices","deltaCenterShift","computeVectorProjectionRatio","vectorCenterVertex","edgeVector","normalToComputeAngle","adjBonesIndices","getTriangleMeshBonesIndices","notAdjBoneIndex","scaling","boneScaling","One","adjTriangleMesh","vertexIndex","matrix","computeFinPosWorldMatrix","rotatedCenterPoint","rotatedWorldVertices","adjTriangle","adjTriangleCenter","adjPointCenterVector","rotationQuaternion","Quaternion","RotationAxis","rotationNode","rotatedTriangleVertices","computeRotatedTriangleVertices","bonesRotations","computeBonesRotationAngle","BigInt","bonesFirstRotations","getAngleBonesRotation","rotatedTriangleIndices","rotationSpeed","getRotationSpeed","deltaTimeInMs","getEngine","getDeltaTime","setupNodesOnFlipping","setupBonesOnFlipping","completeFlipping","Scalar","LerpAngle","Lerp","slice","setRotation","bonesScaleY","boneIndex","setScale","z","MeshStateIdle","args","TriangleMesh","equilateralTriangleProvider","triangleEdges","triangleVertices","equilateralTriangleRadius","skeletonBonesScaling","skeletonBonesRotation","bonesRotationAngle","scalingNodeInitialPosition","currentState","TRIANGLE_SIDE","findEquilateralTriangle","triangleEdgeLength","createNodesStructure","setupPosition","angleBonesRotation","setAngleBonesRotation","rotations","computeBonesScaling","bone","setupMaterial","rootNode","getNodeByName","positionNode","TransformNode","Identity","triangleMeshScalingRatio","triangleCenter","pitchCorrection","math","setDirection","p1CenterVector","forward","up","rotate","p2CenterVector","p3CenterVector","angleP1ToP3","angleP1ToP2","skeletonMesh","bone1rotation","bone2rotation","bone3rotation","material","StandardMaterial","diffuseColor","getColor","backFaceCulling","alpha","update","trVertices","adjTrVertices","adjacentsMap","trVertice","indexTrVertice","adjTrVertice","indexAdjTrVertice","verticeIndices","k","JsonIcosahedronDeserializer","version","descriptor","parsed","parse","key","value","jsonTriangleMap","_x","_y","_z","triangleMap","idx","isDuplicated","hasPoint","p","haveSameType","shapesVerify","shapes","pivotPoint","adjsPivotPoint","getAdjacentsToPoint","findHexagon","hex","adjs","shape","adjs2","adj2","adjs3","adj3","setupCamera","target","beta","camera","ArcRotateCamera","minZ","lowerRadiusLimit","setupLight","light","HemisphericLight","intensity","setDirectionToTarget","getMeshName","createVertexData","renderNormals","normals","positions","vertexData","VertexData","ComputeNormals","options","updatable","MeshBuilder","CreateLines","color","createMesh","customMesh","Mesh","isPickable","hue","HSVtoRGBToRef","applyToMesh","generateInputMesh","meshName","setupInput","canvas","getRenderingCanvas","attachControl","InputManager","gesturesMap","onPointerObservable","pointerId","PointerEventTypes","POINTERDOWN","POINTERTAP","gestureContext","onDown","POINTERMOVE","gesture","onMove","POINTERUP","onRelease","useGameLogic","loadIcosahedron","fetch","then","response","text","json","deserializer","deserialize","onSceneReady","sceneArg","inputs","attached","pointers","buttons","registerOnTriangleChanged","hexagons","inputManager","SceneLoader","ImportMeshAsync","meshes","skeletons","triangleMeshes","visibility","registerBeforeRender","t","onMeshLoaded","onRender","getTransformNodeByName","SceneComponent","props","reactCanvas","useRef","antialias","engineOptions","adaptToDeviceRatio","sceneOptions","rest","useEffect","current","engine","Engine","Scene","isReady","onReadyObservable","addOnce","observedScene","runRenderLoop","render","resize","window","addEventListener","dispose","removeEventListener","ref","width","innerWidth","height","innerHeight","GameComponent","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","basename","path","element","document","getElementById"],"mappings":"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","file":"static/js/main.b89aba4d.chunk.js","sourcesContent":["import { Nullable, Vector3, Color3 } from '@babylonjs/core';\n\nexport type TriangleVertices = Array<Vector3>;\nexport type TriangleId = bigint;\nexport type AdjacentTriangles = Array<AdjacentTriangle>;\nexport type AdjacentTriangle = Nullable<Triangle>;\n\nexport enum TriangleEdge {\n  First = 0,\n  Second,\n  Third,\n}\n\nexport enum Type {\n  First = 0,\n  Second,\n  Third,\n  Fourth,\n  Fifth,\n  Sixth,\n}\nexport const getTypeCount = (): number => Object.keys(Type).length / 2;\n\nconst colors: Record<Type, Color3> = {\n  [Type.First]: Color3.Blue(),\n  [Type.Second]: Color3.Red(),\n  [Type.Third]: Color3.Yellow(),\n  [Type.Fourth]: Color3.Green(),\n  [Type.Fifth]: Color3.Purple(),\n  [Type.Sixth]: Color3.Gray(),\n};\n\nconst typesCount = Object.keys(Type).length * 0.5;\n\nclass Triangle {\n  //\n  private vertices: TriangleVertices;\n\n  private triangleId: TriangleId;\n\n  private adjacents: AdjacentTriangles = [];\n\n  private type: Type = Type.First;\n\n  public constructor(\n    id: TriangleId,\n    p1: Vector3,\n    p2: Vector3,\n    p3: Vector3,\n    type: Type = Triangle.getRandomType(),\n  ) {\n    this.triangleId = id;\n    this.vertices = [p1, p2, p3];\n    this.type = type;\n  }\n\n  static getTypesCount(): number {\n    return typesCount;\n  }\n\n  static getRandomType(): number {\n    return Math.floor(Math.random() * Triangle.getTypesCount());\n  }\n\n  public getType(): Type {\n    return this.type;\n  }\n\n  public setType(type: Type): void {\n    this.type = type;\n  }\n\n  public getColor(): Color3 {\n    return colors[this.type];\n  }\n\n  public getId(): TriangleId {\n    return this.triangleId;\n  }\n\n  public getName(): string {\n    return `Triangle${this.getId()}`;\n  }\n\n  public p1(): Vector3 {\n    return this.vertices[0];\n  }\n\n  public p2(): Vector3 {\n    return this.vertices[1];\n  }\n\n  public p3(): Vector3 {\n    return this.vertices[2];\n  }\n\n  public getVertices(): TriangleVertices {\n    return this.vertices;\n  }\n\n  public getCenterPoint(): Vector3 {\n    const middlePoint1 = Vector3.Center(this.vertices[0], this.vertices[1]);\n    const center1 = this.vertices[2].add(\n      middlePoint1.subtract(this.vertices[2]).scale(2 / 3),\n    );\n    const middlePoint2 = Vector3.Center(this.vertices[1], this.vertices[2]);\n    const center2 = this.vertices[0].add(\n      middlePoint2.subtract(this.vertices[0]).scale(2 / 3),\n    );\n    const middlePoint3 = Vector3.Center(this.vertices[2], this.vertices[0]);\n    const center3 = this.vertices[1].add(\n      middlePoint3.subtract(this.vertices[1]).scale(2 / 3),\n    );\n    const middlePoint = Vector3.Center(center2, center3);\n    const center = center1.add(middlePoint.subtract(center1).scale(2 / 3));\n\n    return center;\n  }\n\n  public getAdjacents(): AdjacentTriangles {\n    return this.adjacents;\n  }\n\n  public setAdjacent(triangle: AdjacentTriangle, index: TriangleEdge): void {\n    this.adjacents[index] = triangle;\n  }\n\n  public pushAdjacent(triangle: Triangle): void {\n    // eslint-disable-next-line no-console\n    console.assert(this.adjacents.length <= 3, 'FATAL ERROR!!!');\n    if (!this.adjacents.find((tr) => tr?.getId() === triangle.getId())) {\n      this.adjacents.push(triangle);\n    }\n  }\n\n  public isAdjacent(triangle: Triangle): boolean {\n    const isAdjacent = this.adjacents.find(\n      (adj) => adj?.getId() === triangle.getId(),\n    );\n    if (isAdjacent) {\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default Triangle;\n","export const k_triangleAssetName = 'TriangleMesh';\nexport const k_triangleAssetFileName = 'triangle.babylon';\nexport const k_triangleAssetDebugFileName = 'triangleDebug.babylon';\nexport const k_triangleAssetPath = './assets/models/';\n","export const k_triangleScale = 0.95;\nexport const k_epsilon = 0.00000001;\nexport const k_gestureDeltaTimeThreshold = 300;\nexport const k_gestureLength = 40;\n","import Triangle from 'models/Triangle';\n\nabstract class EquilateralTriangleProvider {\n  public abstract findEquilateralTriangle(): Triangle;\n}\n\nexport default EquilateralTriangleProvider;\n","import { Vector3 } from '@babylonjs/core';\nimport { k_epsilon } from 'game-constants';\nimport EquilateralTriangleProvider from 'rendering/TriangleMesh/EquilateralTriangleProvider';\nimport Triangle from 'models/Triangle';\nimport ISubdivisionStrategy from './SubdivisionStrategy/ISubdivisionStrategy';\nexport type Triangles = Array<Triangle>;\ninterface Context {\n  subdivisionStrategy: ISubdivisionStrategy;\n  triangles?: Triangles;\n}\nclass Icosahedron extends EquilateralTriangleProvider {\n  //\n  private triangles: Triangles;\n\n  private triangleCount = 0n;\n\n  private subdivisionStrategy: ISubdivisionStrategy;\n\n  private onTrianglesChanged: (triangles: Triangle[]) => void = () => undefined;\n\n  private genTriangleId(): bigint {\n    this.triangleCount += 1n;\n    return this.triangleCount;\n  }\n\n  public makeTriangle(p1: Vector3, p2: Vector3, p3: Vector3): Triangle {\n    return new Triangle(this.genTriangleId(), p1, p2, p3);\n  }\n\n  public constructor(context: Context) {\n    super();\n    this.subdivisionStrategy = context.subdivisionStrategy;\n    if (context.triangles) {\n      this.triangles = context.triangles;\n    } else {\n      this.triangles = this.computeRegularIcosahedronTriangles();\n      computeAdjacentTriangles(this.triangles);\n    }\n  }\n\n  private computeRegularIcosahedronTriangles() {\n    const phi = (1.0 + Math.sqrt(5.0)) * 0.5; // golden ratio\n    const a = 1.0;\n    const b = 1.0 / phi;\n\n    const points = [\n      new Vector3(0, b, -a),\n      new Vector3(b, a, 0),\n      new Vector3(-b, a, 0),\n      new Vector3(0, b, a),\n      new Vector3(0, -b, a),\n      new Vector3(-a, 0, b),\n      new Vector3(0, -b, -a),\n      new Vector3(a, 0, -b),\n      new Vector3(a, 0, b),\n      new Vector3(-a, 0, -b),\n      new Vector3(b, -a, 0),\n      new Vector3(-b, -a, 0),\n    ].map(Vector3.Normalize);\n\n    const makeTriangle = (indices: Array<number>) =>\n      new Triangle(\n        this.genTriangleId(),\n        points[indices[0]],\n        points[indices[1]],\n        points[indices[2]],\n      );\n\n    const triangles = [\n      [0, 1, 2],\n      [3, 2, 1],\n      [3, 4, 5],\n      [3, 8, 4],\n      [0, 6, 7],\n      [0, 9, 6],\n      [4, 10, 11],\n      [6, 11, 10],\n      [2, 5, 9],\n      [11, 9, 5],\n      [1, 7, 8],\n      [10, 8, 7],\n      [3, 5, 2],\n      [3, 1, 8],\n      [0, 2, 9],\n      [0, 7, 1],\n      [6, 9, 11],\n      [6, 10, 7],\n      [4, 11, 5],\n      [4, 8, 10],\n    ].map(makeTriangle);\n    return triangles;\n  }\n\n  public getTriangles(): Array<Triangle> {\n    return this.triangles;\n  }\n\n  public subdivide(count = 1): void {\n    for (let i = 0; i < count; i += 1) {\n      this.triangles = this.subdivisionStrategy.subdivide(this);\n    }\n    computeAdjacentTriangles(this.triangles);\n  }\n\n  public registerOnTriangleChanged(\n    onTriangleChanged: (triangles: Triangle[]) => void,\n  ): void {\n    this.onTrianglesChanged = onTriangleChanged;\n  }\n\n  public notifyTrianglesChanged(changes: Triangle[]): void {\n    this.onTrianglesChanged(changes);\n  }\n\n  public findEquilateralTriangle(): Triangle {\n    const fractionDigits = 8;\n    const equilateralTriangle = this.triangles.find((tr) => {\n      const edgeLength1 = tr\n        .p1()\n        .subtract(tr.p2())\n        .length()\n        .toFixed(fractionDigits);\n      const edgeLength2 = tr\n        .p2()\n        .subtract(tr.p3())\n        .length()\n        .toFixed(fractionDigits);\n      const edgeLength3 = tr\n        .p3()\n        .subtract(tr.p1())\n        .length()\n        .toFixed(fractionDigits);\n\n      return edgeLength1 === edgeLength2 && edgeLength2 === edgeLength3;\n    });\n    if (!equilateralTriangle) {\n      // eslint-disable-next-line no-console\n      console.warn('Equilateral Triangle not found');\n      // eslint-disable-next-line no-debugger\n      debugger;\n    }\n    return equilateralTriangle || this.triangles[0]; // this.triangles[0] shouldn't ever been returned\n  }\n}\n\nfunction computeAdjacentTriangles(triangles: Triangle[]) {\n  const findPointIndex = (triangle: Triangle, point: Vector3): number =>\n    triangle\n\n      .getVertices()\n\n      .findIndex(\n        (trPoint: Vector3) =>\n          Math.abs(point.subtract(trPoint).length()) < k_epsilon,\n      );\n  triangles.forEach((tr1) => {\n    triangles.forEach((tr2) => {\n      if (tr1.getId() !== tr2.getId()) {\n        const adjacentIndices = [\n          findPointIndex(tr1, tr2.p1()),\n          findPointIndex(tr1, tr2.p2()),\n          findPointIndex(tr1, tr2.p3()),\n        ].filter((i) => i !== -1);\n\n        if (adjacentIndices.length === 2) {\n          const firstIndex = adjacentIndices[0] as number;\n          const secondIndex = adjacentIndices[1] as number;\n\n          const indicesSum = firstIndex + secondIndex;\n          // sum = 1 if indices [0, 1] || [1, 0]\n          // sum = 2 if indices [0, 2] || [2, 0]\n          // sum = 3 if indices [1, 2] || [2, 1]\n          if (indicesSum === 1) {\n            tr1.setAdjacent(tr2, 0);\n          }\n          if (indicesSum === 3) {\n            tr1.setAdjacent(tr2, 1);\n          }\n          if (indicesSum === 2) {\n            tr1.setAdjacent(tr2, 2);\n          }\n        }\n      }\n    });\n  });\n}\n\nexport default Icosahedron;\n","import {\n  AbstractMesh,\n  PointerInfo,\n  Scene,\n  Nullable,\n  Vector2,\n  Vector3,\n} from '@babylonjs/core';\nimport { k_gestureLength, k_gestureDeltaTimeThreshold } from 'game-constants';\nimport TriangleMesh from 'rendering/TriangleMesh';\nimport { getAssetMesh } from 'utils/scene';\nimport Gesture from './Gesture';\n\ninterface GestureContext {\n  scene: Scene;\n  triangleMesh: AbstractMesh;\n  onFlipEnded: () => void;\n}\n\nexport enum Direction {\n  Up = 1,\n  Down,\n}\n\nclass FlipGesture extends Gesture {\n  private context: GestureContext;\n\n  private firstTriangleMesh: Nullable<TriangleMesh>;\n\n  private secondTriangleMesh: Nullable<TriangleMesh>;\n\n  private startPoint: Vector2 = Vector2.Zero();\n\n  private lastEventTimestamp = 0;\n\n  public constructor(context: GestureContext) {\n    super();\n    this.context = context;\n    this.firstTriangleMesh = null;\n    this.secondTriangleMesh = null;\n  }\n\n  public onDown(pointerInfo: PointerInfo): void {\n    const mesh = pointerInfo?.pickInfo?.hit && pointerInfo.pickInfo.pickedMesh;\n\n    if (pointerInfo.event) {\n      this.startPoint = new Vector2(pointerInfo.event.x, pointerInfo.event.y);\n      this.lastEventTimestamp = Date.now();\n    }\n    if (mesh) {\n      this.firstTriangleMesh = this.getTriangleMesh(mesh);\n    }\n  }\n\n  public onMove(pointerInfo: PointerInfo): void {\n    const pickinfo = this.context.scene.pick(\n      this.context.scene.pointerX,\n      this.context.scene.pointerY,\n    );\n    console.log(\n      'pointerInfo.event',\n      JSON.stringify(pointerInfo.event, null, 2),\n    );\n    console.log(\n      'pickinfo.pickedMesh',\n      JSON.stringify(pickinfo?.pickedMesh, null, 2),\n    );\n\n    if (pickinfo && pointerInfo.event.pressure !== 0) {\n      const mesh = pickinfo.pickedMesh;\n\n      if (!this.firstTriangleMesh && mesh) {\n        this.firstTriangleMesh = this.getTriangleMesh(mesh);\n        this.startPoint = new Vector2(\n          this.context.scene.pointerX,\n          this.context.scene.pointerY,\n        );\n        this.lastEventTimestamp = Date.now();\n      }\n\n      if (this.firstTriangleMesh) {\n        const firstTriangle = this.firstTriangleMesh.getTriangle();\n\n        const now = Date.now();\n        const deltaTime = now - this.lastEventTimestamp;\n\n        if (deltaTime > k_gestureDeltaTimeThreshold) {\n          this.startPoint = new Vector2(\n            this.context.scene.pointerX,\n            this.context.scene.pointerY,\n          );\n        } else {\n          const finalPoint = new Vector2(\n            this.context.scene.pointerX,\n            this.context.scene.pointerY,\n          );\n\n          const gestureLength = this.startPoint.subtract(finalPoint).length();\n          const isValidGesture = gestureLength > k_gestureLength;\n\n          if (isValidGesture) {\n            if (\n              mesh &&\n              mesh.metadata &&\n              mesh.metadata.triangle &&\n              mesh.metadata.triangle.getId() !== firstTriangle.getId()\n            ) {\n              const assetMesh = this.getTriangleMesh(mesh);\n\n              if (assetMesh) {\n                const assetMeshID = assetMesh.getTriangle().getId();\n\n                const isAdjacent = !!this.firstTriangleMesh\n                  .getTriangle()\n                  .getAdjacents()\n                  .find((a) => a?.getId() === assetMeshID);\n\n                if (isAdjacent) {\n                  this.secondTriangleMesh = assetMesh;\n                }\n              }\n\n              if (this.secondTriangleMesh) {\n                const secondTriangle = this.secondTriangleMesh.getTriangle();\n                if (firstTriangle.isAdjacent(secondTriangle)) {\n                  let flipEnded = false;\n                  const swapType = (trM1: TriangleMesh, trM2: TriangleMesh) => {\n                    if (trM1 && trM2) {\n                      const tr1 = trM1.getTriangle();\n                      const tr2 = trM2.getTriangle();\n                      const tr1Type = tr1.getType();\n                      const tr2Type = tr2.getType();\n\n                      trM1.reset(tr2Type);\n                      trM2.reset(tr1Type);\n                      const { icosahedron } = this.context.scene.metadata;\n\n                      icosahedron.notifyTrianglesChanged([tr1, tr2]);\n                    }\n                  };\n\n                  this.firstTriangleMesh.flip({\n                    triangleMesh: this.secondTriangleMesh,\n                    direction: Direction.Up,\n                    onFlipEnd: () => {\n                      if (\n                        flipEnded &&\n                        this.firstTriangleMesh &&\n                        this.secondTriangleMesh\n                      ) {\n                        swapType(\n                          this.firstTriangleMesh,\n                          this.secondTriangleMesh,\n                        );\n                        this.context.onFlipEnded();\n                      }\n                      flipEnded = true;\n                    },\n                  });\n                  this.secondTriangleMesh.flip({\n                    triangleMesh: this.firstTriangleMesh,\n                    direction: Direction.Down,\n                    onFlipEnd: () => {\n                      if (\n                        flipEnded &&\n                        this.firstTriangleMesh &&\n                        this.secondTriangleMesh\n                      ) {\n                        swapType(\n                          this.firstTriangleMesh,\n                          this.secondTriangleMesh,\n                        );\n                        this.context.onFlipEnded();\n                      }\n                      flipEnded = true;\n                    },\n                  });\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  public onRelease(pointerInfo: PointerInfo): void {\n    //\n  }\n\n  public getTriangleMesh(mesh: AbstractMesh): Nullable<TriangleMesh> {\n    const originalMesh = getAssetMesh({\n      scene: this.context.scene,\n      triangleMesh: mesh,\n    });\n\n    if (originalMesh) {\n      const { triangleMesh } = originalMesh.metadata;\n      if (triangleMesh) {\n        const vertices = triangleMesh.computeObjSpaceVertices();\n        const scalingRatio = triangleMesh.getScalingRatio();\n        const scaledVertices = vertices.map((v: Vector3) =>\n          v.scale(scalingRatio),\n        );\n        const edges = triangleMesh.computeObjSpaceEdges(scaledVertices);\n\n        if (scaledVertices && edges) {\n          triangleMesh.setVertices(scaledVertices);\n          triangleMesh.setEdges(edges);\n\n          return triangleMesh;\n        }\n      }\n    }\n    return null;\n  }\n}\n\nexport default FlipGesture;\n","import { Vector3 } from '@babylonjs/core';\nimport ISubdivisionStrategy, {\n  Triangles,\n  Triangle,\n  Icosahedron,\n} from './ISubdivisionStrategy';\n\nclass _1to4SubdivisionStrategy implements ISubdivisionStrategy {\n  public subdivide(icosahedron: Icosahedron): Triangles {\n    return icosahedron\n      .getTriangles()\n      .reduce(\n        (prev: Array<Triangle>, curr: Triangle) => [\n          ...prev,\n          ...subdivideTriangle(curr, icosahedron),\n        ],\n        [],\n      );\n  }\n}\nexport default _1to4SubdivisionStrategy;\n\nconst subdivideTriangle = (\n  triangle: Triangle,\n  icosahedron: Icosahedron,\n): Triangles => {\n  const center1 = Vector3.Center(triangle.p2(), triangle.p1());\n  const center2 = Vector3.Center(triangle.p3(), triangle.p2());\n  const center3 = Vector3.Center(triangle.p1(), triangle.p3());\n\n  const p1 = center1.scale(1 / center1.length());\n  const p2 = center2.scale(1 / center2.length());\n  const p3 = center3.scale(1 / center3.length());\n\n  const subTriangles = [\n    icosahedron.makeTriangle(triangle.p1(), p1, p3),\n    icosahedron.makeTriangle(p1, triangle.p2(), p2),\n    icosahedron.makeTriangle(p1, p2, p3),\n    icosahedron.makeTriangle(p3, p2, triangle.p3()),\n  ];\n\n  subTriangles.forEach((tr) => tr.setType(Triangle.getRandomType()));\n\n  return subTriangles;\n};\n","export default {\n  angle90: Math.PI * 0.5,\n  angle120: Math.PI * (2 / 3),\n};\n","import { Nullable } from '@babylonjs/core';\nimport TriangleMesh from '..';\n\nabstract class IMeshState {\n  abstract update(\n    args?: Nullable<{\n      direction?: number;\n      adjacentTriangleMesh?: Nullable<TriangleMesh>;\n    }>,\n  ): Nullable<IMeshState>;\n}\nexport default IMeshState;\n","import { PointerInfo } from '@babylonjs/core';\nexport type GestureId = number;\n\nabstract class Gesture {\n  public abstract onDown(pointerInfo: PointerInfo): void;\n\n  public abstract onMove(pointerInfo: PointerInfo): void;\n\n  public abstract onRelease(pointerInfo: PointerInfo): void;\n}\n\nexport default Gesture;\n","import { Nullable, AbstractMesh, Scene } from '@babylonjs/core';\nexport const getAssetMesh = ({\n  scene,\n  triangleMesh,\n}: {\n  scene: Scene;\n  triangleMesh: Nullable<AbstractMesh>;\n}): Nullable<AbstractMesh> => {\n  if (triangleMesh && triangleMesh.metadata && triangleMesh.metadata.triangle) {\n    const name = triangleMesh.metadata.triangle.getName();\n    const assetMesh = scene.getMeshByName(name);\n    if (assetMesh) {\n      return assetMesh;\n    }\n    // eslint-disable-next-line no-console\n    console.assert(typeof assetMesh === 'object', 'Asset not found');\n  }\n  return null;\n};\n","import {\n  Nullable,\n  Quaternion,\n  Scene,\n  TransformNode,\n  Vector3,\n  Scalar,\n  Bone,\n  MeshBuilder,\n  Color3,\n  StandardMaterial,\n  Matrix,\n} from '@babylonjs/core';\nimport { Direction } from 'components/GameComponent/InputManager/FlipGesture';\nimport {\n  DEBUG_RENDERING_TRIANGLES_CENTER_DURING_ROTATION,\n  DEBUG_RENDERING_BONES_IDENTIFIER,\n} from 'game-constants/debug';\nimport Triangle from 'models/Triangle';\nimport TriangleMesh from '..';\nimport IMeshState from './IMeshState';\nimport MeshStateIdle from './MeshStateIdle';\n\nclass MeshStateRotating extends IMeshState {\n  private nextState: Nullable<IMeshState> = null;\n\n  private scene: Scene;\n\n  private mesh: TriangleMesh;\n\n  private adjacentMesh: TriangleMesh;\n\n  private rotation: {\n    axis: Vector3;\n    angle: number;\n  } = {\n    axis: Vector3.Zero(),\n    angle: 0,\n  };\n\n  private flipNode: Nullable<TransformNode> = null;\n\n  private scalingNode: {\n    node: Nullable<TransformNode>;\n    originalPosition: Vector3;\n    finalPosition: Vector3;\n    rotationAngle: number;\n  } = {\n    node: null,\n    originalPosition: Vector3.Zero(),\n    finalPosition: Vector3.Zero(),\n    rotationAngle: 0,\n  };\n\n  private skeleton: {\n    bones: Nullable<Bone[]>;\n    bonesScaling: Nullable<Vector3>[];\n    bonesIndices: number[];\n    bonesDeformation: number[];\n  } = {\n    bones: [],\n    bonesScaling: [],\n    bonesIndices: [],\n    bonesDeformation: [],\n  };\n\n  private adjBonesScalingY: number[] = [];\n\n  private amount = 0;\n\n  private onFlipEnd?: () => void;\n\n  public constructor({\n    thisTriangleMesh,\n    adjacentTriangleMesh,\n    scene,\n    direction,\n    onFlipEnd,\n  }: {\n    thisTriangleMesh: TriangleMesh;\n    adjacentTriangleMesh: TriangleMesh;\n    scene: Scene;\n    direction?: number;\n    onFlipEnd?: () => void;\n  }) {\n    super();\n    this.scene = scene;\n    this.onFlipEnd = onFlipEnd;\n    this.mesh = thisTriangleMesh;\n    this.adjacentMesh = adjacentTriangleMesh;\n\n    const adjacentsVerticesMap = this.mesh.getAdjacentsVerticesMap(\n      this.adjacentMesh.getTriangle(),\n    );\n\n    const trMesh = this.mesh.getTriangleMesh();\n    if (trMesh) {\n      this.scalingNode.node = trMesh.parent as TransformNode;\n\n      const thisTriangleAdjVertIndices = adjacentsVerticesMap.trAdjs;\n\n      this.rotation.axis = this.computeRotationAxis(thisTriangleAdjVertIndices);\n\n      this.flipNode = this.computeFlipNodePosition(thisTriangleAdjVertIndices);\n\n      const rotationData = this.computeRotationData(thisTriangleAdjVertIndices);\n\n      if (rotationData) {\n        if (direction === Direction.Down) {\n          this.rotation.angle = -rotationData.rotationDownAngle;\n        } else {\n          this.rotation.angle = Math.PI * 2 - rotationData.rotationDownAngle;\n        }\n        // computing length ratio between vector (edge's center - mesh's center) of the first triangle and vector (edge's center - mesh's center) of the second triangle to shift the scaling node during rotation\n        const scalingNodeShiftRatio =\n          rotationData.adjRotationVector.length() /\n          rotationData.rotationVector.length();\n\n        const centerShiftVector =\n          this.computeCenterShiftVector(adjacentsVerticesMap);\n\n        this.scalingNode.originalPosition =\n          this.scalingNode.node.position.clone();\n        this.scalingNode.finalPosition = this.scalingNode.originalPosition\n          .scale(scalingNodeShiftRatio)\n          .subtract(centerShiftVector);\n\n        this.skeleton.bones = trMesh.skeleton && trMesh.skeleton.bones;\n        this.skeleton.bonesIndices = this.getBonesIndices(\n          thisTriangleAdjVertIndices,\n        );\n        this.skeleton.bonesScaling = this.getBonesScaling();\n\n        const adjTriangleAdjVertIndices = adjacentsVerticesMap.adjTrAdjs;\n        this.adjBonesScalingY = this.computeAdjBonesScalingY(\n          adjTriangleAdjVertIndices,\n        );\n\n        const adjTriangleNotAdjVertexIndex = [0, 1, 2].findIndex(\n          (e) =>\n            e !== adjTriangleAdjVertIndices[0] &&\n            e !== adjTriangleAdjVertIndices[1],\n        );\n\n        const index = thisTriangleAdjVertIndices.findIndex((v) => v === 0);\n\n        const adjTriangleVertIndex =\n          index === -1\n            ? adjTriangleNotAdjVertexIndex\n            : adjTriangleAdjVertIndices[index];\n\n        this.scalingNode.rotationAngle =\n          this.computeNodeRotationAngleToVertex(adjTriangleVertIndex);\n\n        this.skeleton.bonesDeformation =\n          this.computeBonesDeformation(adjTriangleVertIndex);\n\n        if (DEBUG_RENDERING_BONES_IDENTIFIER) {\n          const vertices = this.mesh.getVertices();\n          if (vertices) {\n            // eslint-disable-next-line no-console\n            console.log(\n              'TriangleID - ',\n              this.mesh.getTriangle().getId(),\n              'AdjacentTriangleID - ',\n              this.adjacentMesh.getTriangle().getId(),\n            );\n            const meshSPHERE1 = MeshBuilder.CreateSphere(\n              `tr1${this.mesh.getTriangle().getName()}`,\n              {\n                diameter: 0.1,\n              },\n            );\n            meshSPHERE1.parent = this.scalingNode.node;\n            meshSPHERE1.position = vertices[0].scale(1.5);\n            const mat1 = new StandardMaterial(`color${vertices[0]}`, scene);\n            mat1.diffuseColor = new Color3(0, 0, 1);\n            meshSPHERE1.material = mat1;\n            const meshSPHERE2 = MeshBuilder.CreateSphere(\n              `tr2${this.mesh.getTriangle().getName()}`,\n              {\n                diameter: 0.1,\n              },\n            );\n            meshSPHERE2.parent = this.scalingNode.node;\n            meshSPHERE2.position = vertices[1].scale(1.5);\n            const mat2 = new StandardMaterial(`color${vertices[1]}`, scene);\n            mat2.diffuseColor = new Color3(0, 1, 0);\n            meshSPHERE2.material = mat2;\n            const meshSPHERE3 = MeshBuilder.CreateSphere(\n              `tr3${this.mesh.getTriangle().getName()}`,\n              {\n                diameter: 0.1,\n              },\n            );\n            meshSPHERE3.parent = this.scalingNode.node;\n            meshSPHERE3.position = vertices[2].scale(1.5);\n            const mat3 = new StandardMaterial(`color${vertices[2]}`, scene);\n            mat3.diffuseColor = new Color3(1, 0, 0);\n            meshSPHERE3.material = mat3;\n          }\n        }\n      }\n    }\n  }\n\n  private computeRotationAxis(vertIndices: number[]): Vector3 {\n    const vertIndicesSum = this.mesh.getTriangleMeshIndicesSum(vertIndices);\n    const edgeIndex = this.mesh.getTriangleMeshFlipEdgeIndex(vertIndicesSum);\n    const edges = this.mesh.getEdges() as Vector3[];\n\n    return edges[edgeIndex];\n  }\n\n  private computeFlipNodePosition(\n    vertIndices: number[],\n  ): Nullable<TransformNode> {\n    if (this.scalingNode.node) {\n      const flipNode = this.scalingNode.node.parent as TransformNode;\n      const vertices = this.mesh.getVertices();\n      if (flipNode && vertices) {\n        const flipNodeCenter = Vector3.Zero(); // node position in object space\n        const edgeCenterPoint = Vector3.Center(\n          vertices[vertIndices[0]],\n          vertices[vertIndices[1]],\n        );\n\n        flipNode.setPositionWithLocalVector(edgeCenterPoint);\n        this.scalingNode.node.position = flipNodeCenter.subtract(\n          flipNode.position,\n        );\n        return flipNode;\n      }\n    }\n    return null;\n  }\n\n  private computeRotationData(indices: number[]): Nullable<{\n    rotationVector: Vector3;\n    adjRotationVector: Vector3;\n    rotationDownAngle: number;\n  }> {\n    const worldSpaceVertices = this.mesh.getTriangle().getVertices();\n\n    const triangleMesh = this.mesh.getTriangleMesh();\n\n    if (triangleMesh) {\n      const vertices = this.mesh.computeObjSpaceVertices();\n\n      if (vertices) {\n        const triangleMeshMatrix = triangleMesh.computeWorldMatrix(true);\n\n        const centerADJ = Vector3.TransformCoordinates(\n          this.adjacentMesh.getTriangle().getCenterPoint(),\n          Matrix.Invert(triangleMeshMatrix),\n        );\n\n        const point1 = this.computeVectorProjectionPoint({\n          vertices,\n          index1: indices[1],\n          index2: indices[0],\n        });\n        const point2 = this.computeVectorProjectionPoint({\n          vertices,\n          center: centerADJ,\n          index1: indices[0],\n          index2: indices[1],\n        });\n\n        const vectorCenterPoint = Vector3.Zero().subtract(point1);\n        const adjVectorCenterPoint = centerADJ.subtract(point2);\n        const normal = Vector3.Cross(vectorCenterPoint, adjVectorCenterPoint);\n\n        const rotationDownAngle = Math.abs(\n          Vector3.GetAngleBetweenVectors(\n            vectorCenterPoint,\n            adjVectorCenterPoint,\n            normal,\n          ),\n        );\n\n        const worldSpaceAdjEdgeCenterPoint = Vector3.Center(\n          worldSpaceVertices[indices[0]],\n          worldSpaceVertices[indices[1]],\n        );\n        const rotationVector = this.mesh\n          .getTriangle()\n          .getCenterPoint()\n          .subtract(worldSpaceAdjEdgeCenterPoint);\n        const adjRotationVector = this.adjacentMesh\n          .getTriangle()\n          .getCenterPoint()\n          .subtract(worldSpaceAdjEdgeCenterPoint);\n\n        return { rotationVector, adjRotationVector, rotationDownAngle };\n      }\n    }\n    return null;\n  }\n\n  private computeVectorProjectionPoint({\n    vertices,\n    center = Vector3.Zero(),\n    index1,\n    index2,\n  }: {\n    vertices: Vector3[];\n    center?: Vector3;\n    index1: number;\n    index2: number;\n  }): Vector3 {\n    const worldSpaceAdjEdge = vertices[index1].subtract(vertices[index2]);\n\n    const projectionAngle = Vector3.GetAngleBetweenVectors(\n      center.subtract(vertices[index2]),\n      worldSpaceAdjEdge,\n      Vector3.Cross(center.subtract(vertices[index2]), worldSpaceAdjEdge),\n    );\n\n    const scalarProjection =\n      center.subtract(vertices[index2]).length() * Math.cos(projectionAngle);\n\n    const point = vertices[index2].add(\n      worldSpaceAdjEdge.scale(scalarProjection / worldSpaceAdjEdge.length()),\n    );\n\n    return point;\n  }\n\n  private computeCenterShiftVector(\n    verticesMap: Record<string, number[]>,\n  ): Vector3 {\n    const adjVertices = this.adjacentMesh.getVertices();\n    const vertices = this.mesh.getVertices();\n    const vertIndices = verticesMap.trAdjs;\n    const adjVertIndices = verticesMap.adjTrAdjs;\n\n    if (adjVertices && vertices) {\n      const vectorProjectionRatio = this.computeVectorProjectionRatio(\n        vertices,\n        vertIndices,\n      );\n\n      const adjVectorProjectionRatio = this.computeVectorProjectionRatio(\n        adjVertices,\n        adjVertIndices,\n      );\n\n      const deltaCenterShift = vectorProjectionRatio - adjVectorProjectionRatio;\n\n      const edgeVector = vertices[vertIndices[1]].subtract(\n        vertices[vertIndices[0]],\n      );\n      const centerShiftVector = edgeVector.scale(deltaCenterShift);\n\n      return centerShiftVector;\n    }\n    return Vector3.Zero();\n  }\n\n  private computeVectorProjectionRatio(\n    vertices: Vector3[],\n    indices: number[],\n  ): number {\n    const vectorCenterVertex = Vector3.Zero().subtract(vertices[indices[0]]);\n    const edgeVector = vertices[indices[1]].subtract(vertices[indices[0]]);\n    const normalToComputeAngle = Vector3.Cross(vectorCenterVertex, edgeVector);\n\n    const projectionAngle = Vector3.GetAngleBetweenVectors(\n      vectorCenterVertex,\n      edgeVector,\n      normalToComputeAngle,\n    );\n\n    const scalarProjection =\n      vectorCenterVertex.length() * Math.cos(projectionAngle);\n\n    const vectorProjectionRatio = Math.abs(\n      scalarProjection / edgeVector.length(),\n    );\n\n    return vectorProjectionRatio;\n  }\n\n  private getBonesIndices(indices: number[]): number[] {\n    const adjBonesIndices = this.mesh.getTriangleMeshBonesIndices(indices);\n\n    const notAdjBoneIndex = [0, 1, 2].findIndex(\n      (e) => e !== adjBonesIndices[0] && e !== adjBonesIndices[1],\n    );\n\n    const bonesIndices = [...adjBonesIndices, notAdjBoneIndex];\n\n    return bonesIndices;\n  }\n\n  private getBonesScaling(): Vector3[] {\n    if (this.skeleton.bones) {\n      const firstBoneScaling =\n        this.skeleton.bones[this.skeleton.bonesIndices[0]].scaling;\n      const secondBoneScaling =\n        this.skeleton.bones[this.skeleton.bonesIndices[1]].scaling;\n      const notAdjBoneScaling =\n        this.skeleton.bones[this.skeleton.bonesIndices[2]].scaling;\n\n      const bonesScaling = [\n        firstBoneScaling,\n        secondBoneScaling,\n        notAdjBoneScaling,\n      ];\n      return bonesScaling.map((boneScaling) => boneScaling.clone());\n    }\n    // eslint-disable-next-line no-console\n    console.assert(this.skeleton.bones, 'Skeleton must exist');\n    return [Vector3.One(), Vector3.One(), Vector3.One()];\n  }\n\n  private computeAdjBonesScalingY(indices: number[]): number[] {\n    let adjBonesScalingY = [1, 1, 1];\n    const adjTriangleMesh = this.adjacentMesh.getTriangleMesh();\n\n    if (adjTriangleMesh) {\n      const skeleton =\n        adjTriangleMesh.skeleton && adjTriangleMesh.skeleton.bones;\n\n      if (skeleton) {\n        const bonesIndices =\n          this.adjacentMesh.getTriangleMeshBonesIndices(indices);\n        const notAdjBoneIndex = [0, 1, 2].findIndex(\n          (e) => e !== bonesIndices[0] && e !== bonesIndices[1],\n        );\n\n        adjBonesScalingY = [\n          skeleton[bonesIndices[0]].scaling.y,\n          skeleton[bonesIndices[1]].scaling.y,\n          skeleton[notAdjBoneIndex].scaling.y,\n        ];\n      }\n    }\n    return adjBonesScalingY;\n  }\n\n  private computeNodeRotationAngleToVertex(vertexIndex: number): number {\n    const matrix = this.computeFinPosWorldMatrix();\n\n    const rotatedCenterPoint = Vector3.TransformCoordinates(\n      new Vector3(0, 0, 0),\n      matrix,\n    );\n    const vertices = this.mesh.getVertices();\n\n    if (vertices) {\n      const rotatedWorldVertices = vertices.map((v) =>\n        Vector3.TransformCoordinates(v, matrix),\n      );\n\n      const adjTriangle = this.adjacentMesh.getTriangle();\n      const adjTriangleCenter = adjTriangle.getCenterPoint();\n      const adjTriangleVertices = adjTriangle.getVertices();\n      const adjPointCenterVector =\n        adjTriangleVertices[vertexIndex].subtract(adjTriangleCenter);\n\n      const nodeRotationAngle = Vector3.GetAngleBetweenVectors(\n        rotatedWorldVertices[0].subtract(rotatedCenterPoint),\n        adjPointCenterVector,\n        adjTriangleCenter,\n      );\n\n      return nodeRotationAngle;\n    }\n    return 0;\n  }\n\n  private computeFinPosWorldMatrix(): Matrix {\n    const mesh = this.mesh.getTriangleMesh();\n    if (mesh && this.flipNode && this.scalingNode.node) {\n      this.flipNode.rotationQuaternion = Quaternion.RotationAxis(\n        this.rotation.axis,\n        this.rotation.angle,\n      );\n      this.scalingNode.node.position = this.scalingNode.finalPosition;\n\n      const rotationNode = this.scalingNode.node.parent as TransformNode;\n      const positionNode = rotationNode.parent as TransformNode;\n      positionNode.computeWorldMatrix(true);\n      rotationNode.computeWorldMatrix(true);\n      this.flipNode.computeWorldMatrix(true);\n      this.scalingNode.node.computeWorldMatrix(true);\n      const matrix = mesh.computeWorldMatrix(true);\n\n      // RESET Nodes transformations after compute Matrix\n      this.flipNode.rotationQuaternion = Quaternion.RotationAxis(\n        this.rotation.axis,\n        0,\n      );\n      this.scalingNode.node.position = this.scalingNode.originalPosition;\n      return matrix;\n    }\n    // eslint-disable-next-line no-console\n    console.assert(mesh, 'Mesh must exist');\n    return Matrix.Zero();\n  }\n\n  private computeBonesDeformation(index: number): number[] {\n    const rotatedTriangleVertices = this.computeRotatedTriangleVertices(\n      this.adjacentMesh,\n      index,\n    );\n\n    const bonesRotations = this.adjacentMesh.computeBonesRotationAngle({\n      triangle: new Triangle(\n        BigInt(0),\n        rotatedTriangleVertices[0],\n        rotatedTriangleVertices[1],\n        rotatedTriangleVertices[2],\n      ),\n    });\n    const bonesFirstRotations = this.mesh.getAngleBonesRotation();\n\n    const bone1DeltaRotation = bonesFirstRotations[0] + bonesRotations[1];\n    const bone2DeltaRotation = bonesFirstRotations[1] + bonesRotations[0];\n\n    return [bone1DeltaRotation, bone2DeltaRotation];\n  }\n\n  private computeRotatedTriangleVertices(\n    mesh: TriangleMesh,\n    vertexIndex: number,\n  ): Vector3[] {\n    let rotatedTriangleIndices: number[] = [];\n    switch (vertexIndex) {\n      case 0: {\n        rotatedTriangleIndices = [0, 1, 2];\n        break;\n      }\n      case 1: {\n        rotatedTriangleIndices = [1, 2, 0];\n        break;\n      }\n      case 2: {\n        rotatedTriangleIndices = [2, 0, 1];\n        break;\n      }\n      default:\n    }\n    const vertices = mesh.getTriangle().getVertices();\n\n    const customTriangleVertices = rotatedTriangleIndices.map(\n      (i) => vertices[i],\n    );\n\n    return customTriangleVertices;\n  }\n\n  public update(): Nullable<IMeshState> {\n    const rotationSpeed = this.getRotationSpeed();\n    const deltaTimeInMs = this.scene.getEngine().getDeltaTime();\n    const { amount } = this;\n\n    if (amount < 1) {\n      this.setupNodesOnFlipping(amount);\n      this.setupBonesOnFlipping(amount);\n\n      this.amount += rotationSpeed * (deltaTimeInMs / 1000);\n\n      if (DEBUG_RENDERING_TRIANGLES_CENTER_DURING_ROTATION) {\n        const scalingNode = this.scalingNode.node as TransformNode;\n        const meshLine = MeshBuilder.CreateSphere(\n          `tr${this.mesh.getTriangle().getName()}`,\n          {\n            diameter: 0.1,\n          },\n        );\n        meshLine.parent = scalingNode;\n      }\n    } else if (amount >= 1) {\n      this.completeFlipping();\n    }\n\n    return this.nextState;\n  }\n\n  private getRotationSpeed(): number {\n    const rpm = 5;\n    const rotationSpeed = (rpm / 60) * Math.PI * 2;\n    return rotationSpeed;\n  }\n\n  private setupNodesOnFlipping(amount: number): void {\n    if (this.flipNode && this.scalingNode.node) {\n      this.flipNode.rotationQuaternion = Quaternion.RotationAxis(\n        this.rotation.axis,\n        Scalar.LerpAngle(0, this.rotation.angle, amount),\n      );\n      this.scalingNode.node.position = Vector3.Lerp(\n        this.scalingNode.originalPosition,\n        this.scalingNode.finalPosition,\n        amount,\n      );\n      this.scalingNode.node.rotation.y = Scalar.LerpAngle(\n        0,\n        -this.scalingNode.rotationAngle,\n        amount,\n      );\n    }\n  }\n\n  private setupBonesOnFlipping(amount: number): void {\n    const { bones, bonesDeformation, bonesScaling } = this.skeleton;\n    const rotationSpeed = this.getRotationSpeed();\n    const deltaTimeInMs = this.scene.getEngine().getDeltaTime();\n\n    if (bones && bonesDeformation && bonesScaling) {\n      bones.slice(0, 2).forEach((b, i) => {\n        const { rotation } = b;\n        rotation.y -= Scalar.Lerp(\n          0,\n          bonesDeformation[i],\n          rotationSpeed * (deltaTimeInMs / 1000),\n        );\n        b.setRotation(rotation);\n      });\n\n      const bonesScaleY = bonesScaling.map(\n        (boneScaling, i) =>\n          boneScaling &&\n          Scalar.Lerp(boneScaling.y, this.adjBonesScalingY[i], amount),\n      ) as number[];\n      if (bonesScaleY) {\n        this.skeleton.bonesIndices.forEach((boneIndex, i) => {\n          bones[boneIndex].setScale(\n            new Vector3(\n              bones[boneIndex].scaling.x,\n              bonesScaleY[i],\n              bones[boneIndex].scaling.z,\n            ),\n          );\n        });\n      }\n    }\n  }\n\n  private completeFlipping(): void {\n    this.nextState = new MeshStateIdle({\n      triangleMesh: this.mesh,\n      scene: this.scene,\n    });\n    if (this.onFlipEnd) {\n      this.onFlipEnd();\n    }\n  }\n}\nexport default MeshStateRotating;\n","import { Nullable, Scene } from '@babylonjs/core';\nimport TriangleMesh from '..';\nimport IMeshState from './IMeshState';\nimport MeshStateRotating from './MeshStateRotating';\n\nclass MeshStateIdle extends IMeshState {\n  private triangleMesh: TriangleMesh;\n\n  private nextState: Nullable<IMeshState> = null;\n\n  private scene: Scene;\n\n  public constructor({\n    triangleMesh,\n    scene,\n  }: {\n    triangleMesh: TriangleMesh;\n    scene: Scene;\n  }) {\n    super();\n    this.triangleMesh = triangleMesh;\n    this.scene = scene;\n  }\n\n  public update(\n    args: Nullable<{\n      direction?: number;\n      adjacentTriangleMesh?: Nullable<TriangleMesh>;\n      onFlipEnd?: () => void;\n    }> = null,\n  ): Nullable<IMeshState> {\n    if (args && args.adjacentTriangleMesh && args.direction) {\n      this.nextState = new MeshStateRotating({\n        thisTriangleMesh: this.triangleMesh,\n        adjacentTriangleMesh: args.adjacentTriangleMesh,\n        scene: this.scene,\n        direction: args.direction,\n        onFlipEnd: args.onFlipEnd,\n      });\n    }\n    return this.nextState;\n  }\n}\nexport default MeshStateIdle;\n","import Triangle, { Type } from 'models/Triangle';\nimport {\n  AbstractMesh,\n  Scene,\n  TransformNode,\n  Vector3,\n  StandardMaterial,\n  Nullable,\n  Quaternion,\n  Matrix,\n  MeshBuilder,\n} from '@babylonjs/core';\nimport { addAxisToScene, math } from 'utils';\nimport { k_triangleAssetName } from 'game-constants/identifiers';\nimport { k_epsilon, k_triangleScale } from 'game-constants';\nimport { DEBUG_RENDERING_ROTATION_NODE_ALIGNMENT } from 'game-constants/debug';\nimport EquilateralTriangleProvider from './EquilateralTriangleProvider';\nimport IMeshState from './State/IMeshState';\nimport MeshStateIdle from './State/MeshStateIdle';\n\nclass TriangleMesh {\n  private scene: Scene;\n\n  private triangle: Triangle;\n\n  private triangleMesh: Nullable<AbstractMesh>;\n\n  private triangleEdges: Nullable<Vector3[]> = null;\n\n  private triangleVertices: Nullable<Vector3[]> = null;\n\n  private equilateralTriangleRadius: number;\n\n  private scalingRatio: number;\n\n  private skeletonBonesScaling?: Vector3[];\n\n  private skeletonBonesRotation?: Vector3[];\n\n  private bonesRotationAngle: number[] = [];\n\n  private scalingNodeInitialPosition: Vector3 = Vector3.Zero();\n\n  private currentState: IMeshState;\n\n  public constructor({\n    scene,\n    triangle,\n    equilateralTriangleProvider,\n  }: {\n    scene: Scene;\n    triangle: Triangle;\n    equilateralTriangleProvider: EquilateralTriangleProvider;\n  }) {\n    this.currentState = new MeshStateIdle({ triangleMesh: this, scene });\n    this.triangle = triangle;\n    this.triangleMesh = null;\n    this.scene = scene;\n\n    const TRIANGLE_RADIUS = 1;\n    const TRIANGLE_SIDE = TRIANGLE_RADIUS * (3 / Math.sqrt(3));\n\n    const equilateralTriangle =\n      equilateralTriangleProvider.findEquilateralTriangle();\n\n    const triangleEdgeLength = equilateralTriangle\n      .p1()\n      .subtract(equilateralTriangle.p2())\n      .length();\n    this.scalingRatio =\n      (1 / TRIANGLE_SIDE) * triangleEdgeLength * k_triangleScale;\n\n    this.equilateralTriangleRadius = equilateralTriangle\n      .p1()\n      .subtract(equilateralTriangle?.getCenterPoint())\n      .length();\n    const mesh = scene.getMeshByName(k_triangleAssetName);\n\n    if (mesh) {\n      const triangleMesh = mesh.clone(triangle.getName(), mesh);\n      this.triangleMesh = triangleMesh;\n      if (triangleMesh) {\n        triangleMesh.metadata = { triangleMesh: this };\n\n        this.createNodesStructure(scene);\n\n        this.setupPosition(scene, this.scalingRatio);\n\n        triangleMesh.skeleton =\n          mesh &&\n          mesh.skeleton &&\n          mesh.skeleton.clone(`skeleton${triangle.getId()}`);\n\n        const angleBonesRotation = this.computeBonesRotationAngle({\n          triangle: this.triangle,\n        });\n\n        this.setAngleBonesRotation(angleBonesRotation);\n\n        const rotations = this.computeBonesDeformation();\n        const bonesScaleY = this.computeBonesScaling();\n\n        if (\n          this.triangleMesh &&\n          this.triangleMesh.skeleton &&\n          rotations &&\n          bonesScaleY\n        ) {\n          this.triangleMesh.skeleton.bones.forEach((bone, index) => {\n            bone.setRotation(rotations[index]);\n            bone.scale(1, bonesScaleY[index], 1);\n          });\n\n          this.skeletonBonesScaling = this.triangleMesh.skeleton.bones.map(\n            ({ scaling }) => new Vector3(scaling.x, scaling.y, scaling.z),\n          );\n          this.skeletonBonesRotation = this.triangleMesh.skeleton.bones.map(\n            ({ rotation }) => new Vector3(rotation.x, rotation.y, rotation.z),\n          );\n        }\n\n        this.setupMaterial();\n      }\n    }\n  }\n\n  private createNodesStructure(scene: Scene): void {\n    if (this.triangleMesh) {\n      const rootNode = scene.getNodeByName('root');\n      const positionNode = new TransformNode(\n        `positionNode${this.triangle.getId()}`,\n      );\n      positionNode.parent = rootNode;\n      const rotationNode = new TransformNode(\n        `rotationNode${this.triangle.getId()}`,\n      );\n      rotationNode.parent = positionNode;\n      const flipNode = new TransformNode(`flipNode${this.triangle.getId()}`);\n      flipNode.parent = rotationNode;\n      const scalingNode = new TransformNode(\n        `scalingNode${this.triangle.getId()}`,\n      );\n      flipNode.rotationQuaternion = Quaternion.Identity();\n\n      scalingNode.parent = flipNode;\n      this.triangleMesh.parent = scalingNode;\n      this.scalingNodeInitialPosition = scalingNode.position;\n    }\n  }\n\n  private setupPosition(scene: Scene, triangleMeshScalingRatio: number): void {\n    const positionNode = scene.getNodeByName(\n      `positionNode${this.triangle.getId()}`,\n    );\n    const rotationNode = scene.getNodeByName(\n      `rotationNode${this.triangle.getId()}`,\n    );\n    const scalingNode = scene.getNodeByName(\n      `scalingNode${this.triangle.getId()}`,\n    );\n\n    const triangleCenter = this.triangle.getCenterPoint();\n    const direction = triangleCenter; // Center - origin\n\n    const yawCorrection = 0;\n    const pitchCorrection = math.angle90;\n    const rollCorrection = 0;\n    if (positionNode && rotationNode && scalingNode && this.triangleMesh) {\n      (positionNode as TransformNode).setDirection(\n        direction,\n        yawCorrection,\n        pitchCorrection,\n        rollCorrection,\n      );\n      (rotationNode as TransformNode).position = new Vector3(\n        0,\n        direction.length(),\n        0,\n      );\n      (scalingNode as TransformNode).scaling = new Vector3(\n        triangleMeshScalingRatio,\n        triangleMeshScalingRatio,\n        triangleMeshScalingRatio,\n      );\n      const p1CenterVector = this.triangle.p1().subtract(triangleCenter);\n\n      const angle = Vector3.GetAngleBetweenVectors(\n        (rotationNode as TransformNode).forward,\n        p1CenterVector,\n        (rotationNode as TransformNode).up,\n      );\n\n      if (Math.abs(angle) > 0.05) {\n        (rotationNode as TransformNode).rotate(this.triangleMesh.up, angle);\n      } else if (DEBUG_RENDERING_ROTATION_NODE_ALIGNMENT) {\n        addAxisToScene({\n          scene,\n          size: 0.5,\n          parent: rotationNode as TransformNode,\n        });\n        MeshBuilder.CreateLines('line', {\n          points: [this.triangle.p1(), triangleCenter],\n        });\n      }\n    }\n  }\n\n  public computeBonesRotationAngle({\n    triangle,\n  }: {\n    triangle: Triangle;\n  }): number[] {\n    const triangleCenter = triangle.getCenterPoint();\n    const p1CenterVector = triangle.p1().subtract(triangleCenter);\n    const p2CenterVector = triangle.p2().subtract(triangleCenter);\n    const p3CenterVector = triangle.p3().subtract(triangleCenter);\n\n    const positionNode = this.scene.getNodeByName(\n      `positionNode${this.getTriangle().getId()}`,\n    );\n\n    if (positionNode) {\n      const angleP1ToP3 = Vector3.GetAngleBetweenVectors(\n        p1CenterVector,\n        p3CenterVector,\n        (positionNode as TransformNode).up,\n      );\n      const angleP1ToP2 = Vector3.GetAngleBetweenVectors(\n        p1CenterVector,\n        p2CenterVector,\n        (positionNode as TransformNode).up,\n      );\n      const deltaAngle1 = angleP1ToP3 - math.angle120;\n      const deltaAngle2 = angleP1ToP2 + math.angle120;\n\n      return [deltaAngle1, deltaAngle2, 0];\n    }\n    return [0, 0, 0];\n  }\n\n  public setAngleBonesRotation(rotations: number[]): void {\n    this.bonesRotationAngle = rotations;\n  }\n\n  public computeBonesDeformation(): Vector3[] {\n    // eslint-disable-next-line no-console\n    console.assert(\n      this.triangleMesh && this.triangleMesh.skeleton,\n      'Mesh and skeleton must exist',\n    );\n    if (this.triangleMesh && this.triangleMesh.skeleton) {\n      const skeletonMesh = this.triangleMesh.skeleton;\n\n      const bone1rotation = skeletonMesh.bones[0].rotation.clone();\n      const bone2rotation = skeletonMesh.bones[1].rotation.clone();\n      const bone3rotation = skeletonMesh.bones[2].rotation.clone();\n\n      bone1rotation.y += this.bonesRotationAngle[0];\n      bone2rotation.y += this.bonesRotationAngle[1];\n\n      return [bone1rotation, bone2rotation, bone3rotation];\n    }\n    return [Vector3.Zero(), Vector3.Zero(), Vector3.Zero()];\n  }\n\n  public computeBonesScaling(): number[] {\n    const triangleCenter = this.triangle.getCenterPoint();\n    const p1CenterVector = this.triangle.p1().subtract(triangleCenter);\n    const p2CenterVector = this.triangle.p2().subtract(triangleCenter);\n    const p3CenterVector = this.triangle.p3().subtract(triangleCenter);\n    if (\n      this.triangleMesh &&\n      this.triangleMesh.skeleton &&\n      this.equilateralTriangleRadius\n    ) {\n      const scaleBones = [\n        p3CenterVector.length() / this.equilateralTriangleRadius,\n        p2CenterVector.length() / this.equilateralTriangleRadius,\n        p1CenterVector.length() / this.equilateralTriangleRadius,\n      ];\n\n      return scaleBones;\n    }\n    return [1, 1, 1];\n  }\n\n  public setupMaterial(): void {\n    if (this.triangleMesh) {\n      const material = new StandardMaterial(\n        `meshMaterial${this.triangle.getId()}`,\n        this.scene,\n      );\n      material.diffuseColor = this.triangle.getColor();\n      material.backFaceCulling = false;\n      material.alpha = 1;\n      this.triangleMesh.material = material;\n    }\n  }\n\n  public getTriangle(): Triangle {\n    return this.triangle;\n  }\n\n  public getTriangleMesh(): Nullable<AbstractMesh> {\n    return this.triangleMesh;\n  }\n\n  public getVertices(): Nullable<Vector3[]> {\n    return this.triangleVertices;\n  }\n\n  public setVertices(vertices: Vector3[]): void {\n    this.triangleVertices = vertices;\n  }\n\n  public getEdges(): Nullable<Vector3[]> {\n    return this.triangleEdges;\n  }\n\n  public setEdges(edges: Vector3[]): void {\n    this.triangleEdges = edges;\n  }\n\n  public getScalingRatio(): number {\n    return this.scalingRatio;\n  }\n\n  public flip({\n    triangleMesh,\n    direction,\n    onFlipEnd,\n  }: {\n    triangleMesh: TriangleMesh;\n    direction: number;\n    onFlipEnd?: () => void;\n  }): void {\n    const context = {\n      adjacentTriangleMesh: triangleMesh,\n      direction,\n      onFlipEnd,\n    };\n    this.update(context);\n  }\n\n  public update(context?: {\n    adjacentTriangleMesh: TriangleMesh;\n    direction: number;\n    onFlipEnd?: () => void;\n  }): void {\n    const nextState = this.currentState.update(context);\n\n    if (nextState) {\n      this.currentState = nextState;\n    }\n  }\n\n  public computeObjSpaceVertices(): Vector3[] | undefined {\n    if (this.triangle && this.triangleMesh) {\n      const tr = this.triangle;\n      const matrix = this.triangleMesh.computeWorldMatrix(true);\n      const vertices = [\n        Vector3.TransformCoordinates(tr.p1(), Matrix.Invert(matrix)),\n        Vector3.TransformCoordinates(tr.p2(), Matrix.Invert(matrix)),\n        Vector3.TransformCoordinates(tr.p3(), Matrix.Invert(matrix)),\n      ];\n\n      return vertices;\n    }\n    // eslint-disable-next-line no-console\n    console.assert(this.triangleMesh && this.triangle, 'Asset not found');\n    return undefined;\n  }\n\n  public computeObjSpaceEdges(vertices: Vector3[]): Vector3[] {\n    const edges = vertices.map((v, i) =>\n      v.subtract(vertices[(i + 1) % vertices.length]),\n    );\n    return edges;\n  }\n\n  public getAdjacentsVerticesMap(\n    adjTriangle: Triangle,\n  ): Record<string, number[]> {\n    const trVertices = this.triangle.getVertices();\n    const adjTrVertices = adjTriangle.getVertices();\n    const adjacentsMap: Record<string, number[]> = {\n      trAdjs: [],\n      adjTrAdjs: [],\n    };\n    if (trVertices && adjTrVertices) {\n      trVertices.forEach((trVertice: Vector3, indexTrVertice: number) => {\n        adjTrVertices.forEach(\n          (adjTrVertice: Vector3, indexAdjTrVertice: number) => {\n            if (adjTrVertice.subtract(trVertice).length() < k_epsilon) {\n              adjacentsMap.trAdjs.push(indexTrVertice);\n              adjacentsMap.adjTrAdjs.push(indexAdjTrVertice);\n            }\n          },\n        );\n      });\n    }\n    return adjacentsMap;\n  }\n\n  public getTriangleMeshBonesIndices(verticeIndices: number[]): number[] {\n    const bonesIndices: number[] = [];\n    verticeIndices.forEach((k, i) => {\n      switch (k) {\n        case 0:\n          bonesIndices[i] = 2;\n          break;\n        case 1:\n          bonesIndices[i] = 1;\n          break;\n        case 2:\n          bonesIndices[i] = 0;\n          break;\n        default:\n      }\n    });\n    return bonesIndices;\n  }\n\n  public getTriangleMeshIndicesSum(verticeIndices: number[]): number {\n    return verticeIndices.reduce((curr, prev) => curr + prev);\n  }\n\n  public getTriangleMeshFlipEdgeIndex(indicesSum: number): number {\n    switch (indicesSum) {\n      case 1:\n        return 0;\n      case 2:\n        return 2;\n      case 3:\n        return 1;\n      default:\n    }\n    // eslint-disable-next-line no-console\n    console.assert(true, 'return value should be a number beetwen 0 and 2');\n    return -1;\n  }\n\n  public getAngleBonesRotation(): number[] {\n    return this.bonesRotationAngle;\n  }\n\n  public reset(type: Type): void {\n    const mesh = this.triangleMesh;\n    if (mesh && mesh.skeleton) {\n      mesh.skeleton.bones.forEach((b, i) => {\n        if (this.skeletonBonesScaling) {\n          b.setScale(this.skeletonBonesScaling[i]);\n        }\n        if (this.skeletonBonesRotation) {\n          b.setRotation(this.skeletonBonesRotation[i]);\n        }\n      });\n    }\n    const scalingNode = mesh?.parent as TransformNode;\n    const flipNode = scalingNode.parent as TransformNode;\n    scalingNode.position = this.scalingNodeInitialPosition;\n    scalingNode.rotation.y = 0;\n    flipNode.position = this.scalingNodeInitialPosition;\n    flipNode.rotationQuaternion = new Quaternion(0, 0, 0, 1);\n\n    this.triangle.setType(type);\n    this.setupMaterial();\n  }\n}\n\nexport default TriangleMesh;\n","import { Vector3 } from '@babylonjs/core';\nimport { TriangleEdge } from 'models/Triangle';\nimport IIcosahedronDeserializer, {\n  Icosahedron,\n  Triangle,\n  Triangles,\n  ISubdivisionStrategy,\n} from './IIcosahedronDeserializer';\n\ninterface AdjacentJSON {\n  triangleId: number;\n}\ninterface VertexJSON {\n  _x: number;\n  _y: number;\n  _z: number;\n}\n\ninterface TriangleJson {\n  triangleId: bigint;\n  vertices: Array<VertexJSON>;\n  type: number;\n  adjacents: Array<AdjacentJSON>;\n}\n\nclass JsonIcosahedronDeserializer implements IIcosahedronDeserializer {\n  private version = '1.0.0';\n\n  public deserialize(\n    descriptor: string,\n    subdivisionStrategy: ISubdivisionStrategy,\n  ): Icosahedron {\n    const parsed = JSON.parse(descriptor, (key, value) => {\n      if (key === 'jsonSerializerVersion') {\n        // eslint-disable-next-line no-console\n        console.assert(\n          this.version === value,\n          'Mismatching serializer/deserializer versions',\n        );\n      }\n      return value;\n    });\n    const jsonTriangleMap = parsed.triangles.reduce(\n      (prev: any, curr: { triangleId: any }) => {\n        const id = `${curr.triangleId}`;\n        return { ...prev, [id]: curr };\n      },\n      {},\n    );\n    const triangles = parsed.triangles.map((triangle: TriangleJson) => {\n      const { triangleId, vertices, type } = triangle;\n      // eslint-disable-next-line no-underscore-dangle\n      const p1 = new Vector3(vertices[0]._x, vertices[0]._y, vertices[0]._z);\n      // eslint-disable-next-line no-underscore-dangle\n      const p2 = new Vector3(vertices[1]._x, vertices[1]._y, vertices[1]._z);\n      // eslint-disable-next-line no-underscore-dangle\n      const p3 = new Vector3(vertices[2]._x, vertices[2]._y, vertices[2]._z);\n\n      return new Triangle(triangleId, p1, p2, p3, type);\n    });\n    const triangleMap = triangles.reduce(\n      (prev: any, curr: { getId: () => bigint }) => {\n        const id = `${curr.getId()}`;\n        return { ...prev, [id]: curr };\n      },\n      {},\n    );\n    triangles.forEach((tr: Triangle) => {\n      const id = `${tr.getId()}`;\n      jsonTriangleMap[id].adjacents.forEach(\n        (adj: { triangleId: number }, idx: TriangleEdge) => {\n          tr.setAdjacent(triangleMap[`${adj.triangleId}`], idx);\n        },\n      );\n      return tr;\n    });\n    return new Icosahedron({\n      triangles,\n      subdivisionStrategy,\n    });\n  }\n}\nexport default JsonIcosahedronDeserializer;\n","import { Vector3 } from '@babylonjs/core';\nimport { k_epsilon } from 'game-constants/index';\nimport Triangle from 'models/Triangle';\n\nexport const isDuplicated = (\n  triangles: Triangle[],\n  triangle: Triangle,\n): boolean => !!triangles.find((e) => e.getId() === triangle.getId());\n\nexport const hasPoint = (tr: Triangle, point: Vector3): boolean =>\n  !!tr.getVertices().find((p) => p.subtract(point).length() < k_epsilon);\n\nexport const haveSameType = (tr1: Triangle, tr2: Triangle): boolean =>\n  tr1.getType() === tr2.getType();\n","import { Vector3 } from '@babylonjs/core';\nimport { Nullable } from '@babylonjs/core/types';\nimport Triangle from 'models/Triangle';\nimport { isDuplicated, hasPoint, haveSameType } from 'gameplay/utils';\n\nexport type Hexagon = Triangle[];\nexport type Hexagons = Hexagon[];\n\nexport const shapesVerify = (triangles: Triangle[]): Hexagons => {\n  const shapes: Hexagons = [];\n  triangles.forEach((tr) => {\n    const shapesList = [\n      { pivotPoint: tr.p1(), adjsPivotPoint: getAdjacentsToPoint(tr, 1) },\n      { pivotPoint: tr.p2(), adjsPivotPoint: getAdjacentsToPoint(tr, 2) },\n      { pivotPoint: tr.p3(), adjsPivotPoint: getAdjacentsToPoint(tr, 0) },\n    ]\n      .map(({ pivotPoint, adjsPivotPoint }) =>\n        findHexagon(tr, pivotPoint, adjsPivotPoint),\n      )\n      .filter((hex) => !!hex) as Hexagons;\n    shapesList.forEach((hex: Hexagon) => shapes.push(hex));\n  });\n\n  return shapes;\n};\n\nconst findHexagon = (\n  tr: Triangle,\n  point: Vector3,\n  adjs: Triangle[],\n): Nullable<Hexagon> => {\n  const shape: Triangle[] = [tr];\n  if (\n    adjs[0] &&\n    adjs[1] &&\n    haveSameType(tr, adjs[0]) &&\n    haveSameType(tr, adjs[1])\n  ) {\n    shape.push(adjs[0]);\n    shape.push(adjs[1]);\n    adjs.forEach((adj) => {\n      const adjs2 = adj\n        ?.getAdjacents()\n        .find(\n          (adj2) =>\n            adj2?.getType() === tr.getType() &&\n            adj2.getId() !== tr.getId() &&\n            hasPoint(adj2, point),\n        );\n\n      if (adjs2) {\n        if (!isDuplicated(shape, adjs2)) {\n          shape.push(adjs2);\n        }\n\n        if (adj && hasPoint(adjs2, point)) {\n          const adjs3 = adjs2\n            ?.getAdjacents()\n            .find(\n              (adj3) =>\n                adj3?.getType() === tr.getType() &&\n                adj3.getId() !== adj.getId() &&\n                hasPoint(adj3, point),\n            );\n\n          if (adjs3 && hasPoint(adjs3, point)) {\n            if (!isDuplicated(shape, adjs3)) {\n              shape.push(adjs3);\n            }\n          }\n        }\n      }\n    });\n  }\n  if (shape.length === 6) {\n    const hexagon = shape as Hexagon;\n    return hexagon;\n  }\n\n  return null;\n};\n\nconst getAdjacentsToPoint = (tr: Triangle, index: number): Triangle[] =>\n  tr.getAdjacents().filter((a, i) => i !== index) as Triangle[];\n","import { ArcRotateCamera, Vector3, Scene } from '@babylonjs/core';\n\nconst setupCamera = (scene: Scene, target: Vector3): ArcRotateCamera => {\n  const alpha = -Math.PI * 0.5;\n  const beta = Math.PI * 0.4;\n  const radius = 3;\n  const camera = new ArcRotateCamera(\n    'camera',\n    alpha,\n    beta,\n    radius,\n    target,\n    scene,\n  );\n  camera.minZ = 0.1;\n  camera.lowerRadiusLimit = 1.5; // we dont' want to get too close\n  return camera;\n};\n\nexport default setupCamera;\n","import { Scene, HemisphericLight, Vector3 } from '@babylonjs/core';\n\nconst setupLight = (scene: Scene, target: Vector3): void => {\n  const light = new HemisphericLight('light', new Vector3(0, 1, 0), scene);\n  light.intensity = 1.1;\n  light.setDirectionToTarget(target);\n  // light.parent = camera;\n};\n\nexport default setupLight;\n","import {\n  TransformNode,\n  Vector3,\n  Scene,\n  Mesh,\n  StandardMaterial,\n  VertexData,\n  Color3,\n  MeshBuilder,\n  PointerEventTypes,\n} from '@babylonjs/core';\nimport {\n  DEBUG_RENDERING_ADJACENTS,\n  DEBUG_RENDERING_ALL_TRIANGLES_CENTER,\n} from 'game-constants/debug';\n\nimport Triangle, { TriangleId } from 'models/Triangle';\n\nconst getMeshName = (triangleId: TriangleId): string => {\n  const meshName = `Input${triangleId}`;\n  return meshName;\n};\n\nconst generateInputMesh = (\n  name: string,\n  scene: Scene,\n  triangles: Array<Triangle>,\n  renderNormals = false,\n): void => {\n  //\n  const rootNode = new TransformNode(name, scene);\n\n  triangles.forEach((triangle) => {\n    if (DEBUG_RENDERING_ALL_TRIANGLES_CENTER) {\n      const line = MeshBuilder.CreateLines(`tr${triangle.getName()}`, {\n        points: [\n          triangle.getCenterPoint().scale(1.05),\n          triangle.getCenterPoint(),\n        ],\n      });\n      line.color = new Color3(0, 0, 0);\n    }\n\n    const vertexData = createVertexData(triangle, renderNormals);\n    const meshName = getMeshName(triangle.getId());\n    const mesh = createMesh(meshName, scene, vertexData);\n    mesh.parent = rootNode;\n    mesh.metadata = { triangle };\n  });\n\n  if (DEBUG_RENDERING_ADJACENTS) {\n    scene.onPointerObservable.add((pointerInfo) => {\n      switch (pointerInfo.type) {\n        case PointerEventTypes.POINTERDOWN:\n          {\n            const mesh =\n              pointerInfo?.pickInfo?.hit && pointerInfo.pickInfo.pickedMesh;\n            const metadata = mesh && mesh.metadata;\n            if (metadata) {\n              const { triangle } = metadata;\n              const adjacentIds: Array<TriangleId> = triangle\n                .getAdjacents()\n                .map((tr: Triangle) => tr?.getId() || -1);\n\n              adjacentIds.forEach((adjId) => {\n                const adjMesh = scene.getMeshByName(getMeshName(adjId));\n\n                if (adjMesh && adjMesh.material) {\n                  adjMesh.material.alpha = 0.5;\n                  const mat: StandardMaterial =\n                    adjMesh.material as StandardMaterial;\n                  mat.diffuseColor = new Color3(0, 0, 0);\n                }\n              });\n            }\n          }\n\n          break;\n        default:\n          break;\n      }\n    });\n  }\n};\n\nconst createVertexData = (triangle: Triangle, renderNormals: boolean) => {\n  const normals: Array<number> = [];\n  const indices: Array<number> = [0, 1, 2];\n  const positions = triangle\n    .getVertices()\n    .reduce(\n      (prev: number[], curr: Vector3): number[] => [\n        ...prev,\n        curr.x,\n        curr.y,\n        curr.z,\n      ],\n      [],\n    );\n  const vertexData = new VertexData();\n  VertexData.ComputeNormals(positions, indices, normals);\n\n  vertexData.positions = positions;\n  vertexData.indices = indices;\n  vertexData.normals = normals;\n\n  if (renderNormals) {\n    // Setup to debugging triangles face direction\n    {\n      const options = {\n        points: [\n          triangle.p1(),\n          triangle.p1().add(new Vector3(normals[0], normals[1], normals[2])),\n        ],\n        updatable: true,\n      };\n      const lines = MeshBuilder.CreateLines('lines', options);\n      lines.color = new Color3(1, 0, 0);\n    }\n    {\n      const options = {\n        points: [\n          triangle.p2(),\n          triangle.p2().add(new Vector3(normals[3], normals[4], normals[5])),\n        ],\n        updatable: true,\n      };\n      const lines = MeshBuilder.CreateLines('lines', options);\n      lines.color = new Color3(1, 0, 0);\n    }\n    {\n      const options = {\n        points: [\n          triangle.p3(),\n          triangle.p3().add(new Vector3(normals[6], normals[7], normals[8])),\n        ],\n        updatable: true,\n      };\n      const lines = MeshBuilder.CreateLines('lines', options);\n      lines.color = new Color3(1, 0, 0);\n    }\n  }\n\n  return vertexData;\n};\n\nconst createMesh = (\n  name: string,\n  scene: Scene,\n  vertexData: VertexData,\n): Mesh => {\n  const customMesh = new Mesh(name, scene);\n  customMesh.isPickable = true;\n  const material = new StandardMaterial('myMaterial', scene);\n  const hue = Math.random() * 255;\n  const saturation = 1;\n  const value = 1;\n  Color3.HSVtoRGBToRef(hue, saturation, value, material.diffuseColor);\n  material.backFaceCulling = false;\n  material.alpha = 0;\n  customMesh.material = material;\n  vertexData.applyToMesh(customMesh, true);\n  return customMesh;\n};\n\nexport default generateInputMesh;\n","import { ArcRotateCamera, Scene } from '@babylonjs/core';\nimport Triangle from 'models/Triangle';\nimport generateInputMesh from './generateInputMesh';\n\nconst setupInput = (\n  scene: Scene,\n  camera: ArcRotateCamera,\n  triangles: Triangle[],\n): void => {\n  const canvas = scene.getEngine().getRenderingCanvas();\n  camera.attachControl(canvas, true);\n  generateInputMesh('icosahedron', scene, triangles);\n};\n\nexport default setupInput;\n","import {\n  Scene,\n  PointerEventTypes,\n  ArcRotateCamera,\n  AbstractMesh,\n} from '@babylonjs/core';\n\nimport Triangle from 'models/Triangle';\nimport Gesture, { GestureId } from './Gesture';\nimport FlipGesture from './FlipGesture';\nimport setupInput from './setupInput';\n\nclass InputManager {\n  //\n  private scene: Scene;\n\n  private gesturesMap: Record<GestureId, Gesture> = {};\n\n  public constructor(\n    scene: Scene,\n    camera: ArcRotateCamera,\n    triangles: Triangle[],\n  ) {\n    this.scene = scene;\n    setupInput(scene, camera, triangles);\n  }\n\n  public onMeshLoaded(triangleMesh: AbstractMesh): void {\n    this.scene.onPointerObservable.add((pointerInfo) => {\n      const { pointerId } = pointerInfo.event;\n      switch (pointerInfo.type) {\n        case PointerEventTypes.POINTERDOWN:\n        case PointerEventTypes.POINTERTAP:\n          {\n            const mesh =\n              pointerInfo?.pickInfo?.hit && pointerInfo.pickInfo.pickedMesh;\n            if (mesh) {\n              const gestureContext = {\n                scene: this.scene,\n                triangleMesh,\n                onFlipEnded: () => {\n                  delete this.gesturesMap[pointerId];\n                },\n              };\n              this.gesturesMap[pointerId] = new FlipGesture(gestureContext);\n              this.gesturesMap[pointerId].onDown(pointerInfo);\n            }\n          }\n          break;\n\n        case PointerEventTypes.POINTERMOVE:\n          {\n            let gesture = this.gesturesMap[pointerId];\n            if (!gesture) {\n              const gestureContext = {\n                scene: this.scene,\n                triangleMesh,\n                onFlipEnded: () => {\n                  delete this.gesturesMap[pointerId];\n                },\n              };\n              gesture = new FlipGesture(gestureContext);\n              this.gesturesMap[pointerId] = gesture;\n            }\n\n            gesture.onMove(pointerInfo);\n          }\n          break;\n        case PointerEventTypes.POINTERUP:\n          {\n            const gesture = this.gesturesMap[pointerId];\n            if (gesture) {\n              gesture.onRelease(pointerInfo);\n            }\n            delete this.gesturesMap[pointerId];\n          }\n          break;\n        default:\n          break;\n      }\n    });\n  }\n}\n\nexport default InputManager;\n","import {\n  Vector3,\n  Scene,\n  SceneLoader,\n  ArcRotateCameraPointersInput,\n} from '@babylonjs/core';\nimport {\n  k_triangleAssetName,\n  k_triangleAssetDebugFileName,\n  k_triangleAssetPath,\n} from 'game-constants/identifiers';\nimport Icosahedron from 'models/Icosahedron';\nimport _1to4SubdivisionStrategy from 'models/Icosahedron/SubdivisionStrategy/1to4SubdivisionStrategy';\nimport TriangleMesh from 'rendering/TriangleMesh/index';\nimport JsonIcosahedronDeserializer from 'deserializers/JsonIcosahedronDeserializer';\n// import JsonIcosahedronSerializer from 'serializers/JsonIcosahedronSerializer'; // #Serialization\nimport {\n  shapesVerify,\n  Hexagon,\n  Hexagons,\n} from 'gameplay/ShapeDetector/shapesVerify';\nimport Triangle from 'models/Triangle';\nimport setupCamera from 'components/GameComponent/setupCamera';\nimport setupLight from 'components/GameComponent/setupLight';\nimport InputManager from 'components/GameComponent/InputManager';\nimport { DEBUG_RENDERING_ADJS_TRIANGLES_BY_ID } from 'game-constants/debug';\nimport { adjsTrianglesDebug } from 'utils';\n\nconst useGameLogic = (): {\n  onRender: (scene: Scene) => void;\n  onSceneReady: (sceneArg: Scene) => void;\n} => {\n  const loadIcosahedron = async () => {\n    const subdivisionStrategy = new _1to4SubdivisionStrategy();\n    try {\n      const json = await fetch('assets/data/icosahedron-0.json').then(\n        (response) => response.text(),\n      );\n      if (json && json.length) {\n        // eslint-disable-next-line no-console\n        console.log('Icosahedron JSON file loaded.');\n        const deserializer = new JsonIcosahedronDeserializer();\n        return deserializer.deserialize(json, subdivisionStrategy);\n      }\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.log('Icosahedron JSON file was not found.');\n    }\n    const icosahedron = new Icosahedron({ subdivisionStrategy });\n    icosahedron.subdivide(2);\n    // #Serialization\n    // const serializer = new JsonIcosahedronSerializer();\n    // const json = serializer.serialize(icosahedron);\n    // eslint-disable-next-line no-console\n    // console.log('Icosahedron json', json);\n    return icosahedron;\n  };\n\n  const onSceneReady = async (sceneArg: Scene) => {\n    const scene: Scene = sceneArg;\n    const target = new Vector3(0, 0, 0);\n    const camera = setupCamera(scene, target);\n    (camera.inputs.attached.pointers as ArcRotateCameraPointersInput).buttons =\n      [1];\n    const icosahedron = await loadIcosahedron();\n    // console.log('Icosahedron loaded');\n    icosahedron.registerOnTriangleChanged((triangles) => {\n      const hexagons: Hexagons = shapesVerify(triangles);\n\n      if (hexagons) {\n        hexagons.forEach((hex: Hexagon) => {\n          if (hex) {\n            hex.forEach((tr) => {\n              const mesh = scene.getMeshByName(tr.getName());\n              const trMesh = mesh && mesh.metadata.triangleMesh;\n              trMesh.reset(Triangle.getRandomType());\n            });\n          }\n        });\n      }\n    });\n\n    const triangles = icosahedron.getTriangles();\n\n    scene.metadata = { icosahedron };\n\n    const inputManager = new InputManager(scene, camera, triangles);\n    setupLight(scene, target);\n\n    SceneLoader.ImportMeshAsync(\n      k_triangleAssetName,\n      k_triangleAssetPath,\n      k_triangleAssetDebugFileName,\n    ).then(({ meshes, skeletons }) => {\n      if (meshes && meshes.length > 0 && skeletons) {\n        const assetMesh = meshes[0];\n\n        const trianglesMeshesToRender = DEBUG_RENDERING_ADJS_TRIANGLES_BY_ID\n          ? adjsTrianglesDebug(triangles, 361)\n          : triangles;\n\n        const triangleMeshes = trianglesMeshesToRender.map(\n          (tr) =>\n            new TriangleMesh({\n              scene,\n              triangle: tr,\n              equilateralTriangleProvider: icosahedron,\n            }),\n        );\n        assetMesh.visibility = 0;\n\n        scene.registerBeforeRender(() => {\n          triangleMeshes.forEach((t) => t.update());\n        });\n\n        inputManager.onMeshLoaded(assetMesh);\n      }\n    });\n  };\n\n  const onRender = (scene: Scene) => {\n    const root = scene.getTransformNodeByName('root');\n    if (root) {\n      // const deltaTimeInMillis = scene.getEngine().getDeltaTime();\n      // const rpm = 5;\n      // root.rotation.y += (rpm / 60) * Math.PI * 2 * (deltaTimeInMillis / 1000);\n    }\n  };\n\n  return { onRender, onSceneReady };\n};\n\nexport default useGameLogic;\n","import { Engine, EngineOptions, Scene, SceneOptions } from '@babylonjs/core';\n// fixme: enable this import only on debug\nimport '@babylonjs/inspector';\nimport { DEBUG_RENDERING_WORLD_AXIS } from 'game-constants/debug';\n\nimport React, { useEffect, useRef } from 'react';\nimport { addAxisToScene } from 'utils';\n\ntype onRenderCallback = (a: Scene) => void;\ntype onSceneReadyCallback = (a: Scene) => void;\n\ninterface SceneComponentProps {\n  antialias?: boolean;\n  engineOptions?: EngineOptions;\n  adaptToDeviceRatio?: boolean;\n  sceneOptions?: SceneOptions;\n  onRender: onRenderCallback;\n  onSceneReady: onSceneReadyCallback;\n}\n\nconst SceneComponent: React.FC<SceneComponentProps> = (props) => {\n  const reactCanvas = useRef(null);\n  const {\n    antialias,\n    engineOptions,\n    adaptToDeviceRatio,\n    sceneOptions,\n    //\n    onRender,\n    onSceneReady,\n    ...rest\n  } = props;\n\n  useEffect(() => {\n    if (reactCanvas.current) {\n      const engine = new Engine(\n        reactCanvas.current,\n        antialias,\n        engineOptions,\n        adaptToDeviceRatio,\n      );\n      const scene = new Scene(engine, sceneOptions);\n      if (scene.isReady()) {\n        onSceneReady(scene);\n      } else {\n        scene.onReadyObservable.addOnce((observedScene) =>\n          onSceneReady(observedScene),\n        );\n      }\n\n      engine.runRenderLoop(() => {\n        if (typeof onRender === 'function') {\n          onRender(scene);\n        }\n        scene.render();\n      });\n\n      const resize = () => {\n        scene.getEngine().resize();\n      };\n\n      if (window) {\n        window.addEventListener('resize', resize);\n      }\n\n      if (DEBUG_RENDERING_WORLD_AXIS) {\n        scene.debugLayer.show();\n        // WORLD AXIS\n        addAxisToScene({ scene, size: 5 });\n      }\n\n      return () => {\n        scene.getEngine().dispose();\n\n        if (window) {\n          window.removeEventListener('resize', resize);\n        }\n      };\n    }\n    return undefined;\n  }, [reactCanvas]);\n\n  return (\n    <canvas\n      ref={reactCanvas}\n      width={window.innerWidth}\n      height={window.innerHeight}\n      {...rest}\n    />\n  );\n};\nexport default SceneComponent;\n","import React from 'react';\nimport useGameLogic from 'gameplay/game/useGameLogic';\nimport SceneComponent from 'components/SceneComponent';\n\nconst GameComponent: React.FC = () => {\n  const { onRender, onSceneReady } = useGameLogic();\n  return (\n    <SceneComponent antialias onSceneReady={onSceneReady} onRender={onRender} />\n  );\n};\n\nexport default GameComponent;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import App from './App';\nimport { Route, BrowserRouter, Routes } from 'react-router-dom';\nimport GameComponent from './components/GameComponent/index';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <BrowserRouter basename=\"/xagon-js\">\n      <Routes>\n        <Route path=\"/\" element={<GameComponent />} />\n      </Routes>\n    </BrowserRouter>\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}