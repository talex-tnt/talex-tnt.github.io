{"version":3,"sources":["models/Triangle.ts","game-constants/identifiers.ts","game-constants/index.ts","rendering/TriangleMesh/EquilateralTriangleProvider.ts","models/Icosahedron/index.ts","components/GameComponent/InputManager/FlipGesture.ts","models/Icosahedron/SubdivisionStrategy/1to4SubdivisionStrategy.ts","utils/math.ts","rendering/TriangleMesh/State/IMeshState.ts","components/GameComponent/InputManager/Gesture.ts","utils/index.ts","utils/scene.ts","rendering/TriangleMesh/State/MeshStateRotating.ts","rendering/TriangleMesh/State/MeshStateIdle.ts","rendering/TriangleMesh/index.ts","deserializers/JsonIcosahedronDeserializer.ts","gameplay/utils/index.ts","gameplay/ShapeDetector/shapesVerify.ts","components/GameComponent/setupCamera.tsx","components/GameComponent/setupLight.tsx","components/GameComponent/InputManager/setupInput/generateInputMesh.tsx","components/GameComponent/InputManager/setupInput/index.tsx","components/GameComponent/InputManager/index.tsx","gameplay/game/useGameLogic.ts","components/SceneComponent.tsx","components/GameComponent/index.tsx","reportWebVitals.ts","index.tsx"],"names":["TriangleEdge","Type","k_triangleAssetName","k_epsilon","EquilateralTriangleProvider","colors","First","Color3","Blue","Second","Red","Third","Yellow","Fourth","Green","Fifth","Purple","Sixth","Gray","typesCount","Object","keys","length","Triangle","id","p1","p2","p3","type","getRandomType","vertices","triangleId","adjacents","this","getId","middlePoint1","Vector3","Center","center1","add","subtract","scale","middlePoint2","center2","middlePoint3","center3","middlePoint","triangle","index","console","assert","find","tr","push","isAdjacent","adj","Math","floor","random","getTypesCount","Icosahedron","context","triangles","triangleCount","subdivisionStrategy","onTrianglesChanged","computeRegularIcosahedronTriangles","computeAdjacentTriangles","genTriangleId","b","sqrt","points","map","Normalize","indices","count","i","subdivide","onTriangleChanged","changes","equilateralTriangle","edgeLength1","toFixed","edgeLength2","edgeLength3","warn","findPointIndex","point","getVertices","findIndex","trPoint","abs","forEach","tr1","tr2","adjacentIndices","filter","indicesSum","setAdjacent","Direction","_1to4SubdivisionStrategy","icosahedron","getTriangles","reduce","prev","curr","subdivideTriangle","subTriangles","makeTriangle","setType","angle60","PI","angle90","angle120","IMeshState","Gesture","FlipGesture","firstTriangleMesh","secondTriangleMesh","startPoint","Vector2","Zero","lastEventTimestamp","pointerInfo","mesh","pickInfo","hit","pickedMesh","event","x","y","Date","now","getTriangleMesh","pickinfo","scene","pick","pointerX","pointerY","buttons","firstTriangle","getTriangle","finalPoint","gesture","metadata","assetMesh","assetMeshID","getAdjacents","a","secondTriangle","flipEnded","adjVertices","getAdjacentsVerticesMap","trAdjs","adjVert1","adjVert2","adjVert1ScreenSpace","getScreenSpacePoint","adjVert2ScreenSpace","edgeScreenSpace3D","gestureAngle","v1","v2","scalarProd","modProd","acos","getAngleBetweenVectors2D","isFlipping","isValidAngle","flip","triangleMesh","direction","Up","onFlipEnd","swapType","onFlipEnded","Down","originalMesh","name","getName","getMeshByName","getAssetMesh","computeObjSpaceVertices","scalingRatio","getScalingRatio","scaledVertices","v","edges","computeObjSpaceEdges","setVertices","setEdges","angle","math","trM1","trM2","tr1Type","getType","tr2Type","reset","notifyTrianglesChanged","camera","activeCamera","engine","getEngine","Project","Matrix","Identity","getTransformMatrix","viewport","toGlobal","getRenderWidth","getRenderHeight","getScreenSpaceFromWorldPoint","MeshStateRotating","thisTriangleMesh","adjacentTriangleMesh","nextState","adjacentMesh","rotation","axis","flipNode","scalingNode","node","originalPosition","finalPosition","rotationAngle","skeleton","bones","bonesScaling","bonesIndices","bonesDeformation","adjBonesScalingY","amount","adjacentsVerticesMap","trMesh","parent","thisTriangleAdjVertIndices","computeRotationAxis","computeFlipNodePosition","rotationData","computeRotationData","rotationDownAngle","scalingNodeShiftRatio","adjRotationVector","rotationVector","centerShiftVector","computeCenterShiftVector","position","clone","getBonesIndices","getBonesScaling","adjTriangleAdjVertIndices","adjTrAdjs","computeAdjBonesScalingY","adjTriangleNotAdjVertexIndex","e","adjTriangleVertIndex","computeNodeRotationAngleToVertex","computeBonesDeformation","vertIndices","vertIndicesSum","getTriangleMeshIndicesSum","edgeIndex","getTriangleMeshFlipEdgeIndex","getEdges","flipNodeCenter","edgeCenterPoint","setPositionWithLocalVector","worldSpaceVertices","triangleMeshMatrix","computeWorldMatrix","centerADJ","TransformCoordinates","getCenterPoint","Invert","point1","computeVectorProjectionPoint","index1","index2","point2","center","vectorCenterPoint","adjVectorCenterPoint","normal","Cross","GetAngleBetweenVectors","worldSpaceAdjEdgeCenterPoint","worldSpaceAdjEdge","projectionAngle","scalarProjection","cos","verticesMap","adjVertIndices","deltaCenterShift","computeVectorProjectionRatio","vectorCenterVertex","edgeVector","normalToComputeAngle","adjBonesIndices","getTriangleMeshBonesIndices","notAdjBoneIndex","scaling","boneScaling","One","adjTriangleMesh","vertexIndex","matrix","computeFinPosWorldMatrix","rotatedCenterPoint","rotatedWorldVertices","adjTriangle","adjTriangleCenter","adjPointCenterVector","rotationQuaternion","Quaternion","RotationAxis","rotationNode","rotatedTriangleVertices","computeRotatedTriangleVertices","bonesRotations","computeBonesRotationAngle","BigInt","bonesFirstRotations","getAngleBonesRotation","rotatedTriangleIndices","rotationSpeed","getRotationSpeed","deltaTimeInMs","getDeltaTime","setupNodesOnFlipping","setupBonesOnFlipping","completeFlipping","rpm","Scalar","LerpAngle","Lerp","slice","setRotation","bonesScaleY","boneIndex","setScale","z","MeshStateIdle","args","TriangleMesh","equilateralTriangleProvider","triangleEdges","triangleVertices","equilateralTriangleRadius","skeletonBonesScaling","skeletonBonesRotation","bonesRotationAngle","scalingNodeInitialPosition","currentState","TRIANGLE_SIDE","findEquilateralTriangle","triangleEdgeLength","createNodesStructure","setupPosition","angleBonesRotation","setAngleBonesRotation","rotations","computeBonesScaling","bone","setupMaterial","rootNode","getNodeByName","positionNode","TransformNode","triangleMeshScalingRatio","triangleCenter","pitchCorrection","setDirection","p1CenterVector","forward","up","rotate","p2CenterVector","p3CenterVector","angleP1ToP3","angleP1ToP2","skeletonMesh","bone1rotation","bone2rotation","bone3rotation","material","StandardMaterial","diffuseColor","getColor","backFaceCulling","alpha","update","trVertices","adjTrVertices","adjacentsMap","trVertice","indexTrVertice","adjTrVertice","indexAdjTrVertice","verticeIndices","k","JsonIcosahedronDeserializer","version","descriptor","parsed","JSON","parse","key","value","jsonTriangleMap","_x","_y","_z","triangleMap","idx","isDuplicated","hasPoint","p","haveSameType","shapesVerify","shapes","pivotPoint","adjsPivotPoint","getAdjacentsToPoint","findHexagon","hex","adjs","shape","adjs2","adj2","adjs3","adj3","setupCamera","target","beta","ArcRotateCamera","minZ","lowerRadiusLimit","setupLight","light","HemisphericLight","intensity","setDirectionToTarget","getMeshName","createVertexData","renderNormals","normals","positions","vertexData","VertexData","ComputeNormals","options","updatable","MeshBuilder","CreateLines","color","createMesh","customMesh","Mesh","isPickable","hue","HSVtoRGBToRef","applyToMesh","generateInputMesh","meshName","setupInput","canvas","getRenderingCanvas","attachControl","InputManager","gesturesMap","onPointerObservable","pointerId","PointerEventTypes","POINTERDOWN","POINTERTAP","gestureContext","onDown","POINTERMOVE","onMove","POINTERUP","onRelease","useGameLogic","loadIcosahedron","fetch","then","response","text","json","log","deserializer","deserialize","onSceneReady","sceneArg","inputs","attached","pointers","registerOnTriangleChanged","hexagons","inputManager","SceneLoader","ImportMeshAsync","meshes","skeletons","triangleMeshes","visibility","registerBeforeRender","t","onMeshLoaded","onRender","getTransformNodeByName","SceneComponent","props","reactCanvas","useRef","antialias","engineOptions","adaptToDeviceRatio","sceneOptions","rest","useEffect","current","Engine","Scene","isReady","onReadyObservable","addOnce","observedScene","runRenderLoop","render","resize","window","addEventListener","dispose","removeEventListener","ref","width","innerWidth","height","innerHeight","GameComponent","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","basename","process","path","element","document","getElementById"],"mappings":"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","file":"static/js/main.117029f7.chunk.js","sourcesContent":["import { Nullable, Vector3, Color3 } from '@babylonjs/core';\n\nexport type TriangleVertices = Array<Vector3>;\nexport type TriangleId = bigint;\nexport type AdjacentTriangles = Array<AdjacentTriangle>;\nexport type AdjacentTriangle = Nullable<Triangle>;\n\nexport enum TriangleEdge {\n  First = 0,\n  Second,\n  Third,\n}\n\nexport enum Type {\n  First = 0,\n  Second,\n  Third,\n  Fourth,\n  Fifth,\n  Sixth,\n}\nexport const getTypeCount = (): number => Object.keys(Type).length / 2;\n\nconst colors: Record<Type, Color3> = {\n  [Type.First]: Color3.Blue(),\n  [Type.Second]: Color3.Red(),\n  [Type.Third]: Color3.Yellow(),\n  [Type.Fourth]: Color3.Green(),\n  [Type.Fifth]: Color3.Purple(),\n  [Type.Sixth]: Color3.Gray(),\n};\n\nconst typesCount = Object.keys(Type).length * 0.5;\n\nclass Triangle {\n  //\n  private vertices: TriangleVertices;\n\n  private triangleId: TriangleId;\n\n  private adjacents: AdjacentTriangles = [];\n\n  private type: Type = Type.First;\n\n  public constructor(\n    id: TriangleId,\n    p1: Vector3,\n    p2: Vector3,\n    p3: Vector3,\n    type: Type = Triangle.getRandomType(),\n  ) {\n    this.triangleId = id;\n    this.vertices = [p1, p2, p3];\n    this.type = type;\n  }\n\n  static getTypesCount(): number {\n    return typesCount;\n  }\n\n  static getRandomType(): number {\n    return Math.floor(Math.random() * Triangle.getTypesCount());\n  }\n\n  public getType(): Type {\n    return this.type;\n  }\n\n  public setType(type: Type): void {\n    this.type = type;\n  }\n\n  public getColor(): Color3 {\n    return colors[this.type];\n  }\n\n  public getId(): TriangleId {\n    return this.triangleId;\n  }\n\n  public getName(): string {\n    return `Triangle${this.getId()}`;\n  }\n\n  public p1(): Vector3 {\n    return this.vertices[0];\n  }\n\n  public p2(): Vector3 {\n    return this.vertices[1];\n  }\n\n  public p3(): Vector3 {\n    return this.vertices[2];\n  }\n\n  public getVertices(): TriangleVertices {\n    return this.vertices;\n  }\n\n  public getCenterPoint(): Vector3 {\n    const middlePoint1 = Vector3.Center(this.vertices[0], this.vertices[1]);\n    const center1 = this.vertices[2].add(\n      middlePoint1.subtract(this.vertices[2]).scale(2 / 3),\n    );\n    const middlePoint2 = Vector3.Center(this.vertices[1], this.vertices[2]);\n    const center2 = this.vertices[0].add(\n      middlePoint2.subtract(this.vertices[0]).scale(2 / 3),\n    );\n    const middlePoint3 = Vector3.Center(this.vertices[2], this.vertices[0]);\n    const center3 = this.vertices[1].add(\n      middlePoint3.subtract(this.vertices[1]).scale(2 / 3),\n    );\n    const middlePoint = Vector3.Center(center2, center3);\n    const center = center1.add(middlePoint.subtract(center1).scale(2 / 3));\n\n    return center;\n  }\n\n  public getAdjacents(): AdjacentTriangles {\n    return this.adjacents;\n  }\n\n  public setAdjacent(triangle: AdjacentTriangle, index: TriangleEdge): void {\n    this.adjacents[index] = triangle;\n  }\n\n  public pushAdjacent(triangle: Triangle): void {\n    // eslint-disable-next-line no-console\n    console.assert(this.adjacents.length <= 3, 'FATAL ERROR!!!');\n    if (!this.adjacents.find((tr) => tr?.getId() === triangle.getId())) {\n      this.adjacents.push(triangle);\n    }\n  }\n\n  public isAdjacent(triangle: Triangle): boolean {\n    const isAdjacent = this.adjacents.find(\n      (adj) => adj?.getId() === triangle.getId(),\n    );\n    if (isAdjacent) {\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default Triangle;\n","export const k_triangleAssetName = 'TriangleMesh';\nexport const k_triangleAssetFileName = 'triangle.babylon';\nexport const k_triangleAssetDebugFileName = 'triangleDebug.babylon';\nexport const k_triangleAssetPath = './assets/models/';\n","export const k_triangleScale = 0.95;\nexport const k_epsilon = 0.00000001;\nexport const k_gestureDeltaTimeThreshold = 300;\nexport const k_gestureLength = 40;\n","import Triangle from 'models/Triangle';\n\nabstract class EquilateralTriangleProvider {\n  public abstract findEquilateralTriangle(): Triangle;\n}\n\nexport default EquilateralTriangleProvider;\n","import { Vector3 } from '@babylonjs/core';\nimport { k_epsilon } from 'game-constants';\nimport EquilateralTriangleProvider from 'rendering/TriangleMesh/EquilateralTriangleProvider';\nimport Triangle from 'models/Triangle';\nimport ISubdivisionStrategy from './SubdivisionStrategy/ISubdivisionStrategy';\nexport type Triangles = Array<Triangle>;\ninterface Context {\n  subdivisionStrategy: ISubdivisionStrategy;\n  triangles?: Triangles;\n}\nclass Icosahedron extends EquilateralTriangleProvider {\n  //\n  private triangles: Triangles;\n\n  private triangleCount = 0n;\n\n  private subdivisionStrategy: ISubdivisionStrategy;\n\n  private onTrianglesChanged: (triangles: Triangle[]) => void = () => undefined;\n\n  private genTriangleId(): bigint {\n    this.triangleCount += 1n;\n    return this.triangleCount;\n  }\n\n  public makeTriangle(p1: Vector3, p2: Vector3, p3: Vector3): Triangle {\n    return new Triangle(this.genTriangleId(), p1, p2, p3);\n  }\n\n  public constructor(context: Context) {\n    super();\n    this.subdivisionStrategy = context.subdivisionStrategy;\n    if (context.triangles) {\n      this.triangles = context.triangles;\n    } else {\n      this.triangles = this.computeRegularIcosahedronTriangles();\n      computeAdjacentTriangles(this.triangles);\n    }\n  }\n\n  private computeRegularIcosahedronTriangles() {\n    const phi = (1.0 + Math.sqrt(5.0)) * 0.5; // golden ratio\n    const a = 1.0;\n    const b = 1.0 / phi;\n\n    const points = [\n      new Vector3(0, b, -a),\n      new Vector3(b, a, 0),\n      new Vector3(-b, a, 0),\n      new Vector3(0, b, a),\n      new Vector3(0, -b, a),\n      new Vector3(-a, 0, b),\n      new Vector3(0, -b, -a),\n      new Vector3(a, 0, -b),\n      new Vector3(a, 0, b),\n      new Vector3(-a, 0, -b),\n      new Vector3(b, -a, 0),\n      new Vector3(-b, -a, 0),\n    ].map(Vector3.Normalize);\n\n    const makeTriangle = (indices: Array<number>) =>\n      new Triangle(\n        this.genTriangleId(),\n        points[indices[0]],\n        points[indices[1]],\n        points[indices[2]],\n      );\n\n    const triangles = [\n      [0, 1, 2],\n      [3, 2, 1],\n      [3, 4, 5],\n      [3, 8, 4],\n      [0, 6, 7],\n      [0, 9, 6],\n      [4, 10, 11],\n      [6, 11, 10],\n      [2, 5, 9],\n      [11, 9, 5],\n      [1, 7, 8],\n      [10, 8, 7],\n      [3, 5, 2],\n      [3, 1, 8],\n      [0, 2, 9],\n      [0, 7, 1],\n      [6, 9, 11],\n      [6, 10, 7],\n      [4, 11, 5],\n      [4, 8, 10],\n    ].map(makeTriangle);\n    return triangles;\n  }\n\n  public getTriangles(): Array<Triangle> {\n    return this.triangles;\n  }\n\n  public subdivide(count = 1): void {\n    for (let i = 0; i < count; i += 1) {\n      this.triangles = this.subdivisionStrategy.subdivide(this);\n    }\n    computeAdjacentTriangles(this.triangles);\n  }\n\n  public registerOnTriangleChanged(\n    onTriangleChanged: (triangles: Triangle[]) => void,\n  ): void {\n    this.onTrianglesChanged = onTriangleChanged;\n  }\n\n  public notifyTrianglesChanged(changes: Triangle[]): void {\n    this.onTrianglesChanged(changes);\n  }\n\n  public findEquilateralTriangle(): Triangle {\n    const fractionDigits = 8;\n    const equilateralTriangle = this.triangles.find((tr) => {\n      const edgeLength1 = tr\n        .p1()\n        .subtract(tr.p2())\n        .length()\n        .toFixed(fractionDigits);\n      const edgeLength2 = tr\n        .p2()\n        .subtract(tr.p3())\n        .length()\n        .toFixed(fractionDigits);\n      const edgeLength3 = tr\n        .p3()\n        .subtract(tr.p1())\n        .length()\n        .toFixed(fractionDigits);\n\n      return edgeLength1 === edgeLength2 && edgeLength2 === edgeLength3;\n    });\n    if (!equilateralTriangle) {\n      // eslint-disable-next-line no-console\n      console.warn('Equilateral Triangle not found');\n      // eslint-disable-next-line no-debugger\n      debugger;\n    }\n    return equilateralTriangle || this.triangles[0]; // this.triangles[0] shouldn't ever been returned\n  }\n}\n\nfunction computeAdjacentTriangles(triangles: Triangle[]) {\n  const findPointIndex = (triangle: Triangle, point: Vector3): number =>\n    triangle\n\n      .getVertices()\n\n      .findIndex(\n        (trPoint: Vector3) =>\n          Math.abs(point.subtract(trPoint).length()) < k_epsilon,\n      );\n  triangles.forEach((tr1) => {\n    triangles.forEach((tr2) => {\n      if (tr1.getId() !== tr2.getId()) {\n        const adjacentIndices = [\n          findPointIndex(tr1, tr2.p1()),\n          findPointIndex(tr1, tr2.p2()),\n          findPointIndex(tr1, tr2.p3()),\n        ].filter((i) => i !== -1);\n\n        if (adjacentIndices.length === 2) {\n          const firstIndex = adjacentIndices[0] as number;\n          const secondIndex = adjacentIndices[1] as number;\n\n          const indicesSum = firstIndex + secondIndex;\n          // sum = 1 if indices [0, 1] || [1, 0]\n          // sum = 2 if indices [0, 2] || [2, 0]\n          // sum = 3 if indices [1, 2] || [2, 1]\n          if (indicesSum === 1) {\n            tr1.setAdjacent(tr2, 0);\n          }\n          if (indicesSum === 3) {\n            tr1.setAdjacent(tr2, 1);\n          }\n          if (indicesSum === 2) {\n            tr1.setAdjacent(tr2, 2);\n          }\n        }\n      }\n    });\n  });\n}\n\nexport default Icosahedron;\n","import {\n  AbstractMesh,\n  PointerInfo,\n  Scene,\n  Nullable,\n  Vector2,\n  Vector3,\n} from '@babylonjs/core';\nimport { k_gestureLength, k_gestureDeltaTimeThreshold } from 'game-constants';\nimport TriangleMesh from 'rendering/TriangleMesh';\nimport {\n  getAngleBetweenVectors2D,\n  getScreenSpaceFromWorldPoint,\n  math,\n} from 'utils';\nimport { getAssetMesh } from 'utils/scene';\nimport Gesture from './Gesture';\n\ninterface GestureContext {\n  scene: Scene;\n  triangleMesh: AbstractMesh;\n  onFlipEnded: () => void;\n}\n\nexport enum Direction {\n  Up = 1,\n  Down,\n}\n\nclass FlipGesture extends Gesture {\n  private context: GestureContext;\n\n  private firstTriangleMesh: Nullable<TriangleMesh>;\n\n  private secondTriangleMesh: Nullable<TriangleMesh>;\n\n  private startPoint: Vector2 = Vector2.Zero();\n\n  private lastEventTimestamp = 0;\n\n  public constructor(context: GestureContext) {\n    super();\n    this.context = context;\n    this.firstTriangleMesh = null;\n    this.secondTriangleMesh = null;\n  }\n\n  public onDown(pointerInfo: PointerInfo): void {\n    const mesh = pointerInfo?.pickInfo?.hit && pointerInfo.pickInfo.pickedMesh;\n\n    if (pointerInfo.event) {\n      this.startPoint = new Vector2(pointerInfo.event.x, pointerInfo.event.y);\n      this.lastEventTimestamp = Date.now();\n    }\n    if (mesh) {\n      this.firstTriangleMesh = this.getTriangleMesh(mesh);\n    }\n  }\n\n  public onMove(pointerInfo: PointerInfo): void {\n    const pickinfo = this.context.scene.pick(\n      this.context.scene.pointerX,\n      this.context.scene.pointerY,\n    );\n    if (pickinfo && pointerInfo.event.buttons === 1) {\n      const mesh = pickinfo.pickedMesh;\n\n      if (!this.firstTriangleMesh && mesh) {\n        this.firstTriangleMesh = this.getTriangleMesh(mesh);\n        this.startPoint = new Vector2(\n          this.context.scene.pointerX,\n          this.context.scene.pointerY,\n        );\n        this.lastEventTimestamp = Date.now();\n      }\n\n      if (this.firstTriangleMesh) {\n        const firstTriangle = this.firstTriangleMesh.getTriangle();\n\n        const now = Date.now();\n        const deltaTime = now - this.lastEventTimestamp;\n\n        if (deltaTime > k_gestureDeltaTimeThreshold) {\n          this.startPoint = new Vector2(\n            this.context.scene.pointerX,\n            this.context.scene.pointerY,\n          );\n        } else {\n          const finalPoint = new Vector2(\n            this.context.scene.pointerX,\n            this.context.scene.pointerY,\n          );\n\n          const gesture = this.startPoint.subtract(finalPoint);\n\n          const gestureLength = gesture.length();\n          const isValidGesture = gestureLength > k_gestureLength;\n\n          if (isValidGesture) {\n            if (\n              mesh &&\n              mesh.metadata &&\n              mesh.metadata.triangle &&\n              mesh.metadata.triangle.getId() !== firstTriangle.getId()\n            ) {\n              const assetMesh = this.getTriangleMesh(mesh);\n\n              if (assetMesh) {\n                const assetMeshID = assetMesh.getTriangle().getId();\n\n                const isAdjacent = !!this.firstTriangleMesh\n                  .getTriangle()\n                  .getAdjacents()\n                  .find((a) => a?.getId() === assetMeshID);\n\n                if (isAdjacent) {\n                  this.secondTriangleMesh = assetMesh;\n                }\n              }\n\n              if (this.secondTriangleMesh) {\n                const secondTriangle = this.secondTriangleMesh.getTriangle();\n                if (firstTriangle.isAdjacent(secondTriangle)) {\n                  let flipEnded = false;\n                  const adjVertices =\n                    this.firstTriangleMesh.getAdjacentsVerticesMap(\n                      secondTriangle,\n                    ).trAdjs;\n                  const adjVert1 = firstTriangle.getVertices()[adjVertices[0]];\n                  const adjVert2 = firstTriangle.getVertices()[adjVertices[1]];\n                  const adjVert1ScreenSpace =\n                    this.getScreenSpacePoint(adjVert1);\n                  const adjVert2ScreenSpace =\n                    this.getScreenSpacePoint(adjVert2);\n\n                  if (adjVert1ScreenSpace && adjVert2ScreenSpace) {\n                    const edgeScreenSpace3D =\n                      adjVert2ScreenSpace?.subtract(adjVert1ScreenSpace);\n\n                    const edgeScreenSpace2D = new Vector2(\n                      edgeScreenSpace3D.x,\n                      edgeScreenSpace3D.y,\n                    );\n\n                    const gestureAngle = getAngleBetweenVectors2D(\n                      gesture,\n                      edgeScreenSpace2D,\n                    );\n\n                    if (\n                      !this.firstTriangleMesh.isFlipping() &&\n                      !this.secondTriangleMesh.isFlipping() &&\n                      this.isValidAngle(gestureAngle)\n                    ) {\n                      this.firstTriangleMesh.flip({\n                        triangleMesh: this.secondTriangleMesh,\n                        direction: Direction.Up,\n                        onFlipEnd: () => {\n                          if (\n                            flipEnded &&\n                            this.firstTriangleMesh &&\n                            this.secondTriangleMesh\n                          ) {\n                            this.swapType(\n                              this.firstTriangleMesh,\n                              this.secondTriangleMesh,\n                            );\n                            this.context.onFlipEnded();\n                          }\n                          flipEnded = true;\n                        },\n                      });\n                      this.secondTriangleMesh.flip({\n                        triangleMesh: this.firstTriangleMesh,\n                        direction: Direction.Down,\n                        onFlipEnd: () => {\n                          if (\n                            flipEnded &&\n                            this.firstTriangleMesh &&\n                            this.secondTriangleMesh\n                          ) {\n                            this.swapType(\n                              this.firstTriangleMesh,\n                              this.secondTriangleMesh,\n                            );\n                            this.context.onFlipEnded();\n                          }\n                          flipEnded = true;\n                        },\n                      });\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  public onRelease(pointerInfo: PointerInfo): void {\n    //\n  }\n\n  public getTriangleMesh(mesh: AbstractMesh): Nullable<TriangleMesh> {\n    const originalMesh = getAssetMesh({\n      scene: this.context.scene,\n      triangleMesh: mesh,\n    });\n\n    if (originalMesh) {\n      const { triangleMesh } = originalMesh.metadata;\n      if (triangleMesh) {\n        const vertices = triangleMesh.computeObjSpaceVertices();\n        const scalingRatio = triangleMesh.getScalingRatio();\n        const scaledVertices = vertices.map((v: Vector3) =>\n          v.scale(scalingRatio),\n        );\n        const edges = triangleMesh.computeObjSpaceEdges(scaledVertices);\n\n        if (scaledVertices && edges) {\n          triangleMesh.setVertices(scaledVertices);\n          triangleMesh.setEdges(edges);\n\n          return triangleMesh;\n        }\n      }\n    }\n    return null;\n  }\n\n  public isValidAngle(angle: number): boolean {\n    return angle < math.angle120 && angle > math.angle60;\n  }\n\n  public swapType(trM1: TriangleMesh, trM2: TriangleMesh): void {\n    if (trM1 && trM2) {\n      const tr1 = trM1.getTriangle();\n      const tr2 = trM2.getTriangle();\n      const tr1Type = tr1.getType();\n      const tr2Type = tr2.getType();\n\n      trM1.reset(tr2Type);\n      trM2.reset(tr1Type);\n      const { icosahedron } = this.context.scene.metadata;\n\n      icosahedron.notifyTrianglesChanged([tr1, tr2]);\n    }\n  }\n\n  public getScreenSpacePoint(point: Vector3): Vector3 {\n    return getScreenSpaceFromWorldPoint(this.context.scene, point);\n  }\n}\n\nexport default FlipGesture;\n","import { Vector3 } from '@babylonjs/core';\nimport ISubdivisionStrategy, {\n  Triangles,\n  Triangle,\n  Icosahedron,\n} from './ISubdivisionStrategy';\n\nclass _1to4SubdivisionStrategy implements ISubdivisionStrategy {\n  public subdivide(icosahedron: Icosahedron): Triangles {\n    return icosahedron\n      .getTriangles()\n      .reduce(\n        (prev: Array<Triangle>, curr: Triangle) => [\n          ...prev,\n          ...subdivideTriangle(curr, icosahedron),\n        ],\n        [],\n      );\n  }\n}\nexport default _1to4SubdivisionStrategy;\n\nconst subdivideTriangle = (\n  triangle: Triangle,\n  icosahedron: Icosahedron,\n): Triangles => {\n  const center1 = Vector3.Center(triangle.p2(), triangle.p1());\n  const center2 = Vector3.Center(triangle.p3(), triangle.p2());\n  const center3 = Vector3.Center(triangle.p1(), triangle.p3());\n\n  const p1 = center1.scale(1 / center1.length());\n  const p2 = center2.scale(1 / center2.length());\n  const p3 = center3.scale(1 / center3.length());\n\n  const subTriangles = [\n    icosahedron.makeTriangle(triangle.p1(), p1, p3),\n    icosahedron.makeTriangle(p1, triangle.p2(), p2),\n    icosahedron.makeTriangle(p1, p2, p3),\n    icosahedron.makeTriangle(p3, p2, triangle.p3()),\n  ];\n\n  subTriangles.forEach((tr) => tr.setType(Triangle.getRandomType()));\n\n  return subTriangles;\n};\n","export default {\n  angle60: Math.PI * (1 / 3),\n  angle90: Math.PI * 0.5,\n  angle120: Math.PI * (2 / 3),\n};\n","import { Nullable } from '@babylonjs/core';\nimport TriangleMesh from '..';\n\nabstract class IMeshState {\n  abstract update(\n    args?: Nullable<{\n      direction?: number;\n      adjacentTriangleMesh?: Nullable<TriangleMesh>;\n    }>,\n  ): Nullable<IMeshState>;\n\n  abstract isFlipping(): boolean;\n}\nexport default IMeshState;\n","import { PointerInfo } from '@babylonjs/core';\nexport type GestureId = number;\n\nabstract class Gesture {\n  public abstract onDown(pointerInfo: PointerInfo): void;\n\n  public abstract onMove(pointerInfo: PointerInfo): void;\n\n  public abstract onRelease(pointerInfo: PointerInfo): void;\n}\n\nexport default Gesture;\n","import {\n  DynamicTexture,\n  Mesh,\n  StandardMaterial,\n  Color3,\n  Vector2,\n  Vector3,\n  TransformNode,\n  Scene,\n  Matrix,\n} from '@babylonjs/core';\nimport Triangle from 'models/Triangle';\n\nexport { default as math } from './math';\n\nexport const addAxisToScene = ({\n  scene,\n  size,\n  parent,\n}: {\n  scene: Scene;\n  size: number;\n  parent?: TransformNode;\n}): void => {\n  const makeTextPlane = (text: string, color: string, sizePlane: number) => {\n    const dynamicTexture = new DynamicTexture(\n      'DynamicTexture',\n      50,\n      scene,\n      true,\n    );\n    dynamicTexture.hasAlpha = true;\n    dynamicTexture.drawText(\n      text,\n      5,\n      40,\n      'bold 36px Arial',\n      color,\n      'transparent',\n      true,\n    );\n    const plane = Mesh.CreatePlane('TextPlane', sizePlane, scene, true);\n    plane.material = new StandardMaterial('TextPlaneMaterial', scene);\n    plane.material.backFaceCulling = false;\n    (plane.material as StandardMaterial).specularColor = new Color3(0, 0, 0);\n    (plane.material as StandardMaterial).diffuseTexture = dynamicTexture;\n    if (parent) {\n      plane.parent = parent;\n    }\n    return plane;\n  };\n\n  const axisX = Mesh.CreateLines(\n    'axisX',\n    [Vector3.Zero(), new Vector3(size, 0, 0)],\n    scene,\n  );\n  if (parent) {\n    axisX.parent = parent;\n  }\n  axisX.color = new Color3(1, 0, 0);\n  const xChar = makeTextPlane('X', 'red', size / 10);\n  xChar.position = new Vector3(0.9 * size, -0.05 * size, 0);\n  const axisY = Mesh.CreateLines(\n    'axisY',\n    [Vector3.Zero(), new Vector3(0, size, 0)],\n    scene,\n  );\n  if (parent) {\n    axisY.parent = parent;\n  }\n  axisY.color = new Color3(0, 1, 0);\n  const yChar = makeTextPlane('Y', 'green', size / 10);\n  yChar.position = new Vector3(0, 0.9 * size, -0.05 * size);\n  const axisZ = Mesh.CreateLines(\n    'axisZ',\n    [Vector3.Zero(), new Vector3(0, 0, size)],\n    scene,\n  );\n  if (parent) {\n    axisZ.parent = parent;\n  }\n  axisZ.color = new Color3(0, 0, 1);\n  const zChar = makeTextPlane('Z', 'blue', size / 10);\n  zChar.position = new Vector3(0, 0.05 * size, 0.9 * size);\n};\n\nexport const adjsTrianglesDebug = (\n  triangles: Triangle[],\n  id: number,\n): Triangle[] => {\n  const testTriangle = triangles.filter((t) => t.getId() === BigInt(id));\n  const testAdjacents = testTriangle[0].getAdjacents() as Triangle[];\n  return triangles.filter((t) => {\n    if (testTriangle && testAdjacents) {\n      return (\n        t.getId() === testTriangle[0].getId() ||\n        t.getId() === testAdjacents[0].getId() ||\n        t.getId() === testAdjacents[1].getId() ||\n        t.getId() === testAdjacents[2].getId()\n      );\n    }\n    return t;\n  });\n};\n\nexport const getScreenSpaceFromWorldPoint = (\n  scene: Scene,\n  point: Vector3,\n): Vector3 => {\n  const camera = scene.activeCamera;\n  const engine = scene.getEngine();\n\n  if (camera) {\n    const screenSpacePoint = Vector3.Project(\n      point,\n      Matrix.Identity(),\n      scene.getTransformMatrix(),\n      camera.viewport.toGlobal(\n        engine.getRenderWidth(),\n        engine.getRenderHeight(),\n      ),\n    );\n    return screenSpacePoint;\n  }\n  // eslint-disable-next-line no-console\n  console.assert(true, 'Camera must exist');\n  return Vector3.Zero();\n};\n\nexport const getAngleBetweenVectors2D = (v1: Vector2, v2: Vector2): number => {\n  const scalarProd = v1.x * v2.x + v1.y * v2.y;\n  const modV1 = Math.sqrt(v1.x ** 2 + v1.y ** 2);\n  const modV2 = Math.sqrt(v2.x ** 2 + v2.y ** 2);\n  const modProd = modV1 * modV2;\n\n  const angle = Math.acos(scalarProd / modProd);\n  return angle;\n};\n","import { Nullable, AbstractMesh, Scene } from '@babylonjs/core';\nexport const getAssetMesh = ({\n  scene,\n  triangleMesh,\n}: {\n  scene: Scene;\n  triangleMesh: Nullable<AbstractMesh>;\n}): Nullable<AbstractMesh> => {\n  if (triangleMesh && triangleMesh.metadata && triangleMesh.metadata.triangle) {\n    const name = triangleMesh.metadata.triangle.getName();\n    const assetMesh = scene.getMeshByName(name);\n    if (assetMesh) {\n      return assetMesh;\n    }\n    // eslint-disable-next-line no-console\n    console.assert(typeof assetMesh === 'object', 'Asset not found');\n  }\n  return null;\n};\n","import {\n  Nullable,\n  Quaternion,\n  Scene,\n  TransformNode,\n  Vector3,\n  Scalar,\n  Bone,\n  MeshBuilder,\n  Color3,\n  StandardMaterial,\n  Matrix,\n} from '@babylonjs/core';\nimport { Direction } from 'components/GameComponent/InputManager/FlipGesture';\nimport {\n  DEBUG_RENDERING_TRIANGLES_CENTER_DURING_ROTATION,\n  DEBUG_RENDERING_BONES_IDENTIFIER,\n} from 'game-constants/debug';\nimport Triangle from 'models/Triangle';\nimport TriangleMesh from '..';\nimport IMeshState from './IMeshState';\nimport MeshStateIdle from './MeshStateIdle';\n\nclass MeshStateRotating extends IMeshState {\n  private nextState: Nullable<IMeshState> = null;\n\n  private scene: Scene;\n\n  private mesh: TriangleMesh;\n\n  private adjacentMesh: TriangleMesh;\n\n  private rotation: {\n    axis: Vector3;\n    angle: number;\n  } = {\n    axis: Vector3.Zero(),\n    angle: 0,\n  };\n\n  private flipNode: Nullable<TransformNode> = null;\n\n  private scalingNode: {\n    node: Nullable<TransformNode>;\n    originalPosition: Vector3;\n    finalPosition: Vector3;\n    rotationAngle: number;\n  } = {\n    node: null,\n    originalPosition: Vector3.Zero(),\n    finalPosition: Vector3.Zero(),\n    rotationAngle: 0,\n  };\n\n  private skeleton: {\n    bones: Nullable<Bone[]>;\n    bonesScaling: Nullable<Vector3>[];\n    bonesIndices: number[];\n    bonesDeformation: number[];\n  } = {\n    bones: [],\n    bonesScaling: [],\n    bonesIndices: [],\n    bonesDeformation: [],\n  };\n\n  private adjBonesScalingY: number[] = [];\n\n  private amount = 0;\n\n  private onFlipEnd?: () => void;\n\n  public constructor({\n    thisTriangleMesh,\n    adjacentTriangleMesh,\n    scene,\n    direction,\n    onFlipEnd,\n  }: {\n    thisTriangleMesh: TriangleMesh;\n    adjacentTriangleMesh: TriangleMesh;\n    scene: Scene;\n    direction?: number;\n    onFlipEnd?: () => void;\n  }) {\n    super();\n    this.scene = scene;\n    this.onFlipEnd = onFlipEnd;\n    this.mesh = thisTriangleMesh;\n    this.adjacentMesh = adjacentTriangleMesh;\n\n    const adjacentsVerticesMap = this.mesh.getAdjacentsVerticesMap(\n      this.adjacentMesh.getTriangle(),\n    );\n\n    const trMesh = this.mesh.getTriangleMesh();\n    if (trMesh) {\n      this.scalingNode.node = trMesh.parent as TransformNode;\n\n      const thisTriangleAdjVertIndices = adjacentsVerticesMap.trAdjs;\n\n      this.rotation.axis = this.computeRotationAxis(thisTriangleAdjVertIndices);\n\n      this.flipNode = this.computeFlipNodePosition(thisTriangleAdjVertIndices);\n\n      const rotationData = this.computeRotationData(thisTriangleAdjVertIndices);\n\n      if (rotationData) {\n        if (direction === Direction.Down) {\n          this.rotation.angle = -rotationData.rotationDownAngle;\n        } else {\n          this.rotation.angle = Math.PI * 2 - rotationData.rotationDownAngle;\n        }\n        // computing length ratio between vector (edge's center - mesh's center) of the first triangle and vector (edge's center - mesh's center) of the second triangle to shift the scaling node during rotation\n        const scalingNodeShiftRatio =\n          rotationData.adjRotationVector.length() /\n          rotationData.rotationVector.length();\n\n        const centerShiftVector =\n          this.computeCenterShiftVector(adjacentsVerticesMap);\n\n        this.scalingNode.originalPosition =\n          this.scalingNode.node.position.clone();\n        this.scalingNode.finalPosition = this.scalingNode.originalPosition\n          .scale(scalingNodeShiftRatio)\n          .subtract(centerShiftVector);\n\n        this.skeleton.bones = trMesh.skeleton && trMesh.skeleton.bones;\n        this.skeleton.bonesIndices = this.getBonesIndices(\n          thisTriangleAdjVertIndices,\n        );\n        this.skeleton.bonesScaling = this.getBonesScaling();\n\n        const adjTriangleAdjVertIndices = adjacentsVerticesMap.adjTrAdjs;\n        this.adjBonesScalingY = this.computeAdjBonesScalingY(\n          adjTriangleAdjVertIndices,\n        );\n\n        const adjTriangleNotAdjVertexIndex = [0, 1, 2].findIndex(\n          (e) =>\n            e !== adjTriangleAdjVertIndices[0] &&\n            e !== adjTriangleAdjVertIndices[1],\n        );\n\n        const index = thisTriangleAdjVertIndices.findIndex((v) => v === 0);\n\n        const adjTriangleVertIndex =\n          index === -1\n            ? adjTriangleNotAdjVertexIndex\n            : adjTriangleAdjVertIndices[index];\n\n        this.scalingNode.rotationAngle =\n          this.computeNodeRotationAngleToVertex(adjTriangleVertIndex);\n\n        this.skeleton.bonesDeformation =\n          this.computeBonesDeformation(adjTriangleVertIndex);\n\n        if (DEBUG_RENDERING_BONES_IDENTIFIER) {\n          const vertices = this.mesh.getVertices();\n          if (vertices) {\n            // eslint-disable-next-line no-console\n            console.log(\n              'TriangleID - ',\n              this.mesh.getTriangle().getId(),\n              'AdjacentTriangleID - ',\n              this.adjacentMesh.getTriangle().getId(),\n            );\n            const meshSPHERE1 = MeshBuilder.CreateSphere(\n              `tr1${this.mesh.getTriangle().getName()}`,\n              {\n                diameter: 0.1,\n              },\n            );\n            meshSPHERE1.parent = this.scalingNode.node;\n            meshSPHERE1.position = vertices[0].scale(1.5);\n            const mat1 = new StandardMaterial(`color${vertices[0]}`, scene);\n            mat1.diffuseColor = new Color3(0, 0, 1);\n            meshSPHERE1.material = mat1;\n            const meshSPHERE2 = MeshBuilder.CreateSphere(\n              `tr2${this.mesh.getTriangle().getName()}`,\n              {\n                diameter: 0.1,\n              },\n            );\n            meshSPHERE2.parent = this.scalingNode.node;\n            meshSPHERE2.position = vertices[1].scale(1.5);\n            const mat2 = new StandardMaterial(`color${vertices[1]}`, scene);\n            mat2.diffuseColor = new Color3(0, 1, 0);\n            meshSPHERE2.material = mat2;\n            const meshSPHERE3 = MeshBuilder.CreateSphere(\n              `tr3${this.mesh.getTriangle().getName()}`,\n              {\n                diameter: 0.1,\n              },\n            );\n            meshSPHERE3.parent = this.scalingNode.node;\n            meshSPHERE3.position = vertices[2].scale(1.5);\n            const mat3 = new StandardMaterial(`color${vertices[2]}`, scene);\n            mat3.diffuseColor = new Color3(1, 0, 0);\n            meshSPHERE3.material = mat3;\n          }\n        }\n      }\n    }\n  }\n\n  private computeRotationAxis(vertIndices: number[]): Vector3 {\n    const vertIndicesSum = this.mesh.getTriangleMeshIndicesSum(vertIndices);\n    const edgeIndex = this.mesh.getTriangleMeshFlipEdgeIndex(vertIndicesSum);\n    const edges = this.mesh.getEdges() as Vector3[];\n\n    return edges[edgeIndex];\n  }\n\n  private computeFlipNodePosition(\n    vertIndices: number[],\n  ): Nullable<TransformNode> {\n    if (this.scalingNode.node) {\n      const flipNode = this.scalingNode.node.parent as TransformNode;\n      const vertices = this.mesh.getVertices();\n      if (flipNode && vertices) {\n        const flipNodeCenter = Vector3.Zero(); // node position in object space\n        const edgeCenterPoint = Vector3.Center(\n          vertices[vertIndices[0]],\n          vertices[vertIndices[1]],\n        );\n\n        flipNode.setPositionWithLocalVector(edgeCenterPoint);\n        this.scalingNode.node.position = flipNodeCenter.subtract(\n          flipNode.position,\n        );\n        return flipNode;\n      }\n    }\n    return null;\n  }\n\n  private computeRotationData(indices: number[]): Nullable<{\n    rotationVector: Vector3;\n    adjRotationVector: Vector3;\n    rotationDownAngle: number;\n  }> {\n    const worldSpaceVertices = this.mesh.getTriangle().getVertices();\n\n    const triangleMesh = this.mesh.getTriangleMesh();\n\n    if (triangleMesh) {\n      const vertices = this.mesh.computeObjSpaceVertices();\n\n      if (vertices) {\n        const triangleMeshMatrix = triangleMesh.computeWorldMatrix(true);\n\n        const centerADJ = Vector3.TransformCoordinates(\n          this.adjacentMesh.getTriangle().getCenterPoint(),\n          Matrix.Invert(triangleMeshMatrix),\n        );\n\n        const point1 = this.computeVectorProjectionPoint({\n          vertices,\n          index1: indices[1],\n          index2: indices[0],\n        });\n        const point2 = this.computeVectorProjectionPoint({\n          vertices,\n          center: centerADJ,\n          index1: indices[0],\n          index2: indices[1],\n        });\n\n        const vectorCenterPoint = Vector3.Zero().subtract(point1);\n        const adjVectorCenterPoint = centerADJ.subtract(point2);\n        const normal = Vector3.Cross(vectorCenterPoint, adjVectorCenterPoint);\n\n        const rotationDownAngle = Math.abs(\n          Vector3.GetAngleBetweenVectors(\n            vectorCenterPoint,\n            adjVectorCenterPoint,\n            normal,\n          ),\n        );\n\n        const worldSpaceAdjEdgeCenterPoint = Vector3.Center(\n          worldSpaceVertices[indices[0]],\n          worldSpaceVertices[indices[1]],\n        );\n        const rotationVector = this.mesh\n          .getTriangle()\n          .getCenterPoint()\n          .subtract(worldSpaceAdjEdgeCenterPoint);\n        const adjRotationVector = this.adjacentMesh\n          .getTriangle()\n          .getCenterPoint()\n          .subtract(worldSpaceAdjEdgeCenterPoint);\n\n        return { rotationVector, adjRotationVector, rotationDownAngle };\n      }\n    }\n    return null;\n  }\n\n  private computeVectorProjectionPoint({\n    vertices,\n    center = Vector3.Zero(),\n    index1,\n    index2,\n  }: {\n    vertices: Vector3[];\n    center?: Vector3;\n    index1: number;\n    index2: number;\n  }): Vector3 {\n    const worldSpaceAdjEdge = vertices[index1].subtract(vertices[index2]);\n\n    const projectionAngle = Vector3.GetAngleBetweenVectors(\n      center.subtract(vertices[index2]),\n      worldSpaceAdjEdge,\n      Vector3.Cross(center.subtract(vertices[index2]), worldSpaceAdjEdge),\n    );\n\n    const scalarProjection =\n      center.subtract(vertices[index2]).length() * Math.cos(projectionAngle);\n\n    const point = vertices[index2].add(\n      worldSpaceAdjEdge.scale(scalarProjection / worldSpaceAdjEdge.length()),\n    );\n\n    return point;\n  }\n\n  private computeCenterShiftVector(\n    verticesMap: Record<string, number[]>,\n  ): Vector3 {\n    const adjVertices = this.adjacentMesh.getVertices();\n    const vertices = this.mesh.getVertices();\n    const vertIndices = verticesMap.trAdjs;\n    const adjVertIndices = verticesMap.adjTrAdjs;\n\n    if (adjVertices && vertices) {\n      const vectorProjectionRatio = this.computeVectorProjectionRatio(\n        vertices,\n        vertIndices,\n      );\n\n      const adjVectorProjectionRatio = this.computeVectorProjectionRatio(\n        adjVertices,\n        adjVertIndices,\n      );\n\n      const deltaCenterShift = vectorProjectionRatio - adjVectorProjectionRatio;\n\n      const edgeVector = vertices[vertIndices[1]].subtract(\n        vertices[vertIndices[0]],\n      );\n      const centerShiftVector = edgeVector.scale(deltaCenterShift);\n\n      return centerShiftVector;\n    }\n    return Vector3.Zero();\n  }\n\n  private computeVectorProjectionRatio(\n    vertices: Vector3[],\n    indices: number[],\n  ): number {\n    const vectorCenterVertex = Vector3.Zero().subtract(vertices[indices[0]]);\n    const edgeVector = vertices[indices[1]].subtract(vertices[indices[0]]);\n    const normalToComputeAngle = Vector3.Cross(vectorCenterVertex, edgeVector);\n\n    const projectionAngle = Vector3.GetAngleBetweenVectors(\n      vectorCenterVertex,\n      edgeVector,\n      normalToComputeAngle,\n    );\n\n    const scalarProjection =\n      vectorCenterVertex.length() * Math.cos(projectionAngle);\n\n    const vectorProjectionRatio = Math.abs(\n      scalarProjection / edgeVector.length(),\n    );\n\n    return vectorProjectionRatio;\n  }\n\n  private getBonesIndices(indices: number[]): number[] {\n    const adjBonesIndices = this.mesh.getTriangleMeshBonesIndices(indices);\n\n    const notAdjBoneIndex = [0, 1, 2].findIndex(\n      (e) => e !== adjBonesIndices[0] && e !== adjBonesIndices[1],\n    );\n\n    const bonesIndices = [...adjBonesIndices, notAdjBoneIndex];\n\n    return bonesIndices;\n  }\n\n  private getBonesScaling(): Vector3[] {\n    if (this.skeleton.bones) {\n      const firstBoneScaling =\n        this.skeleton.bones[this.skeleton.bonesIndices[0]].scaling;\n      const secondBoneScaling =\n        this.skeleton.bones[this.skeleton.bonesIndices[1]].scaling;\n      const notAdjBoneScaling =\n        this.skeleton.bones[this.skeleton.bonesIndices[2]].scaling;\n\n      const bonesScaling = [\n        firstBoneScaling,\n        secondBoneScaling,\n        notAdjBoneScaling,\n      ];\n      return bonesScaling.map((boneScaling) => boneScaling.clone());\n    }\n    // eslint-disable-next-line no-console\n    console.assert(this.skeleton.bones, 'Skeleton must exist');\n    return [Vector3.One(), Vector3.One(), Vector3.One()];\n  }\n\n  private computeAdjBonesScalingY(indices: number[]): number[] {\n    let adjBonesScalingY = [1, 1, 1];\n    const adjTriangleMesh = this.adjacentMesh.getTriangleMesh();\n\n    if (adjTriangleMesh) {\n      const skeleton =\n        adjTriangleMesh.skeleton && adjTriangleMesh.skeleton.bones;\n\n      if (skeleton) {\n        const bonesIndices =\n          this.adjacentMesh.getTriangleMeshBonesIndices(indices);\n        const notAdjBoneIndex = [0, 1, 2].findIndex(\n          (e) => e !== bonesIndices[0] && e !== bonesIndices[1],\n        );\n\n        adjBonesScalingY = [\n          skeleton[bonesIndices[0]].scaling.y,\n          skeleton[bonesIndices[1]].scaling.y,\n          skeleton[notAdjBoneIndex].scaling.y,\n        ];\n      }\n    }\n    return adjBonesScalingY;\n  }\n\n  private computeNodeRotationAngleToVertex(vertexIndex: number): number {\n    const matrix = this.computeFinPosWorldMatrix();\n\n    const rotatedCenterPoint = Vector3.TransformCoordinates(\n      new Vector3(0, 0, 0),\n      matrix,\n    );\n    const vertices = this.mesh.getVertices();\n\n    if (vertices) {\n      const rotatedWorldVertices = vertices.map((v) =>\n        Vector3.TransformCoordinates(v, matrix),\n      );\n\n      const adjTriangle = this.adjacentMesh.getTriangle();\n      const adjTriangleCenter = adjTriangle.getCenterPoint();\n      const adjTriangleVertices = adjTriangle.getVertices();\n      const adjPointCenterVector =\n        adjTriangleVertices[vertexIndex].subtract(adjTriangleCenter);\n\n      const nodeRotationAngle = Vector3.GetAngleBetweenVectors(\n        rotatedWorldVertices[0].subtract(rotatedCenterPoint),\n        adjPointCenterVector,\n        adjTriangleCenter,\n      );\n\n      return nodeRotationAngle;\n    }\n    return 0;\n  }\n\n  private computeFinPosWorldMatrix(): Matrix {\n    const mesh = this.mesh.getTriangleMesh();\n    if (mesh && this.flipNode && this.scalingNode.node) {\n      this.flipNode.rotationQuaternion = Quaternion.RotationAxis(\n        this.rotation.axis,\n        this.rotation.angle,\n      );\n      this.scalingNode.node.position = this.scalingNode.finalPosition;\n\n      const rotationNode = this.scalingNode.node.parent as TransformNode;\n      const positionNode = rotationNode.parent as TransformNode;\n      positionNode.computeWorldMatrix(true);\n      rotationNode.computeWorldMatrix(true);\n      this.flipNode.computeWorldMatrix(true);\n      this.scalingNode.node.computeWorldMatrix(true);\n      const matrix = mesh.computeWorldMatrix(true);\n\n      // RESET Nodes transformations after compute Matrix\n      this.flipNode.rotationQuaternion = Quaternion.RotationAxis(\n        this.rotation.axis,\n        0,\n      );\n      this.scalingNode.node.position = this.scalingNode.originalPosition;\n      return matrix;\n    }\n    // eslint-disable-next-line no-console\n    console.assert(mesh, 'Mesh must exist');\n    return Matrix.Zero();\n  }\n\n  private computeBonesDeformation(index: number): number[] {\n    const rotatedTriangleVertices = this.computeRotatedTriangleVertices(\n      this.adjacentMesh,\n      index,\n    );\n\n    const bonesRotations = this.adjacentMesh.computeBonesRotationAngle({\n      triangle: new Triangle(\n        BigInt(0),\n        rotatedTriangleVertices[0],\n        rotatedTriangleVertices[1],\n        rotatedTriangleVertices[2],\n      ),\n    });\n    const bonesFirstRotations = this.mesh.getAngleBonesRotation();\n\n    const bone1DeltaRotation = bonesFirstRotations[0] + bonesRotations[1];\n    const bone2DeltaRotation = bonesFirstRotations[1] + bonesRotations[0];\n\n    return [bone1DeltaRotation, bone2DeltaRotation];\n  }\n\n  private computeRotatedTriangleVertices(\n    mesh: TriangleMesh,\n    vertexIndex: number,\n  ): Vector3[] {\n    let rotatedTriangleIndices: number[] = [];\n    switch (vertexIndex) {\n      case 0: {\n        rotatedTriangleIndices = [0, 1, 2];\n        break;\n      }\n      case 1: {\n        rotatedTriangleIndices = [1, 2, 0];\n        break;\n      }\n      case 2: {\n        rotatedTriangleIndices = [2, 0, 1];\n        break;\n      }\n      default:\n    }\n    const vertices = mesh.getTriangle().getVertices();\n\n    const customTriangleVertices = rotatedTriangleIndices.map(\n      (i) => vertices[i],\n    );\n\n    return customTriangleVertices;\n  }\n\n  public update(): Nullable<IMeshState> {\n    const rotationSpeed = this.getRotationSpeed();\n    const deltaTimeInMs = this.scene.getEngine().getDeltaTime();\n    const { amount } = this;\n\n    if (amount < 1) {\n      this.setupNodesOnFlipping(amount);\n      this.setupBonesOnFlipping(amount);\n\n      this.amount += rotationSpeed * (deltaTimeInMs / 1000);\n\n      if (DEBUG_RENDERING_TRIANGLES_CENTER_DURING_ROTATION) {\n        const scalingNode = this.scalingNode.node as TransformNode;\n        const meshLine = MeshBuilder.CreateSphere(\n          `tr${this.mesh.getTriangle().getName()}`,\n          {\n            diameter: 0.1,\n          },\n        );\n        meshLine.parent = scalingNode;\n      }\n    } else if (amount >= 1) {\n      this.completeFlipping();\n    }\n\n    return this.nextState;\n  }\n\n  private getRotationSpeed(): number {\n    const rpm = 60;\n    const rotationSpeed = (rpm / 60) * Math.PI * 2;\n    return rotationSpeed;\n  }\n\n  private setupNodesOnFlipping(amount: number): void {\n    if (this.flipNode && this.scalingNode.node) {\n      this.flipNode.rotationQuaternion = Quaternion.RotationAxis(\n        this.rotation.axis,\n        Scalar.LerpAngle(0, this.rotation.angle, amount),\n      );\n      this.scalingNode.node.position = Vector3.Lerp(\n        this.scalingNode.originalPosition,\n        this.scalingNode.finalPosition,\n        amount,\n      );\n      this.scalingNode.node.rotation.y = Scalar.LerpAngle(\n        0,\n        -this.scalingNode.rotationAngle,\n        amount,\n      );\n    }\n  }\n\n  private setupBonesOnFlipping(amount: number): void {\n    const { bones, bonesDeformation, bonesScaling } = this.skeleton;\n    const rotationSpeed = this.getRotationSpeed();\n    const deltaTimeInMs = this.scene.getEngine().getDeltaTime();\n\n    if (bones && bonesDeformation && bonesScaling) {\n      bones.slice(0, 2).forEach((b, i) => {\n        const { rotation } = b;\n        rotation.y -= Scalar.Lerp(\n          0,\n          bonesDeformation[i],\n          rotationSpeed * (deltaTimeInMs / 1000),\n        );\n        b.setRotation(rotation);\n      });\n\n      const bonesScaleY = bonesScaling.map(\n        (boneScaling, i) =>\n          boneScaling &&\n          Scalar.Lerp(boneScaling.y, this.adjBonesScalingY[i], amount),\n      ) as number[];\n      if (bonesScaleY) {\n        this.skeleton.bonesIndices.forEach((boneIndex, i) => {\n          bones[boneIndex].setScale(\n            new Vector3(\n              bones[boneIndex].scaling.x,\n              bonesScaleY[i],\n              bones[boneIndex].scaling.z,\n            ),\n          );\n        });\n      }\n    }\n  }\n\n  private completeFlipping(): void {\n    this.nextState = new MeshStateIdle({\n      triangleMesh: this.mesh,\n      scene: this.scene,\n    });\n    if (this.onFlipEnd) {\n      this.onFlipEnd();\n    }\n  }\n\n  public isFlipping(): boolean {\n    return true;\n  }\n}\nexport default MeshStateRotating;\n","import { Nullable, Scene } from '@babylonjs/core';\nimport TriangleMesh from '..';\nimport IMeshState from './IMeshState';\nimport MeshStateRotating from './MeshStateRotating';\n\nclass MeshStateIdle extends IMeshState {\n  private triangleMesh: TriangleMesh;\n\n  private nextState: Nullable<IMeshState> = null;\n\n  private scene: Scene;\n\n  public constructor({\n    triangleMesh,\n    scene,\n  }: {\n    triangleMesh: TriangleMesh;\n    scene: Scene;\n  }) {\n    super();\n    this.triangleMesh = triangleMesh;\n    this.scene = scene;\n  }\n\n  public update(\n    args: Nullable<{\n      direction?: number;\n      adjacentTriangleMesh?: Nullable<TriangleMesh>;\n      onFlipEnd?: () => void;\n    }> = null,\n  ): Nullable<IMeshState> {\n    if (args && args.adjacentTriangleMesh && args.direction) {\n      this.nextState = new MeshStateRotating({\n        thisTriangleMesh: this.triangleMesh,\n        adjacentTriangleMesh: args.adjacentTriangleMesh,\n        scene: this.scene,\n        direction: args.direction,\n        onFlipEnd: args.onFlipEnd,\n      });\n    }\n    return this.nextState;\n  }\n\n  public isFlipping(): boolean {\n    return false;\n  }\n}\nexport default MeshStateIdle;\n","import Triangle, { Type } from 'models/Triangle';\nimport {\n  AbstractMesh,\n  Scene,\n  TransformNode,\n  Vector3,\n  StandardMaterial,\n  Nullable,\n  Quaternion,\n  Matrix,\n  MeshBuilder,\n} from '@babylonjs/core';\nimport { addAxisToScene, math } from 'utils';\nimport { k_triangleAssetName } from 'game-constants/identifiers';\nimport { k_epsilon, k_triangleScale } from 'game-constants';\nimport { DEBUG_RENDERING_ROTATION_NODE_ALIGNMENT } from 'game-constants/debug';\nimport EquilateralTriangleProvider from './EquilateralTriangleProvider';\nimport IMeshState from './State/IMeshState';\nimport MeshStateIdle from './State/MeshStateIdle';\n\nclass TriangleMesh {\n  private scene: Scene;\n\n  private triangle: Triangle;\n\n  private triangleMesh: Nullable<AbstractMesh>;\n\n  private triangleEdges: Nullable<Vector3[]> = null;\n\n  private triangleVertices: Nullable<Vector3[]> = null;\n\n  private equilateralTriangleRadius: number;\n\n  private scalingRatio: number;\n\n  private skeletonBonesScaling?: Vector3[];\n\n  private skeletonBonesRotation?: Vector3[];\n\n  private bonesRotationAngle: number[] = [];\n\n  private scalingNodeInitialPosition: Vector3 = Vector3.Zero();\n\n  private currentState: IMeshState;\n\n  public constructor({\n    scene,\n    triangle,\n    equilateralTriangleProvider,\n  }: {\n    scene: Scene;\n    triangle: Triangle;\n    equilateralTriangleProvider: EquilateralTriangleProvider;\n  }) {\n    this.currentState = new MeshStateIdle({ triangleMesh: this, scene });\n    this.triangle = triangle;\n    this.triangleMesh = null;\n    this.scene = scene;\n\n    const TRIANGLE_RADIUS = 1;\n    const TRIANGLE_SIDE = TRIANGLE_RADIUS * (3 / Math.sqrt(3));\n\n    const equilateralTriangle =\n      equilateralTriangleProvider.findEquilateralTriangle();\n\n    const triangleEdgeLength = equilateralTriangle\n      .p1()\n      .subtract(equilateralTriangle.p2())\n      .length();\n    this.scalingRatio =\n      (1 / TRIANGLE_SIDE) * triangleEdgeLength * k_triangleScale;\n\n    this.equilateralTriangleRadius = equilateralTriangle\n      .p1()\n      .subtract(equilateralTriangle?.getCenterPoint())\n      .length();\n    const mesh = scene.getMeshByName(k_triangleAssetName);\n\n    if (mesh) {\n      const triangleMesh = mesh.clone(triangle.getName(), mesh);\n      this.triangleMesh = triangleMesh;\n      if (triangleMesh) {\n        triangleMesh.metadata = { triangleMesh: this };\n\n        this.createNodesStructure(scene);\n\n        this.setupPosition(scene, this.scalingRatio);\n\n        triangleMesh.skeleton =\n          mesh &&\n          mesh.skeleton &&\n          mesh.skeleton.clone(`skeleton${triangle.getId()}`);\n\n        const angleBonesRotation = this.computeBonesRotationAngle({\n          triangle: this.triangle,\n        });\n\n        this.setAngleBonesRotation(angleBonesRotation);\n\n        const rotations = this.computeBonesDeformation();\n        const bonesScaleY = this.computeBonesScaling();\n\n        if (\n          this.triangleMesh &&\n          this.triangleMesh.skeleton &&\n          rotations &&\n          bonesScaleY\n        ) {\n          this.triangleMesh.skeleton.bones.forEach((bone, index) => {\n            bone.setRotation(rotations[index]);\n            bone.scale(1, bonesScaleY[index], 1);\n          });\n\n          this.skeletonBonesScaling = this.triangleMesh.skeleton.bones.map(\n            ({ scaling }) => new Vector3(scaling.x, scaling.y, scaling.z),\n          );\n          this.skeletonBonesRotation = this.triangleMesh.skeleton.bones.map(\n            ({ rotation }) => new Vector3(rotation.x, rotation.y, rotation.z),\n          );\n        }\n\n        this.setupMaterial();\n      }\n    }\n  }\n\n  private createNodesStructure(scene: Scene): void {\n    if (this.triangleMesh) {\n      const rootNode = scene.getNodeByName('root');\n      const positionNode = new TransformNode(\n        `positionNode${this.triangle.getId()}`,\n      );\n      positionNode.parent = rootNode;\n      const rotationNode = new TransformNode(\n        `rotationNode${this.triangle.getId()}`,\n      );\n      rotationNode.parent = positionNode;\n      const flipNode = new TransformNode(`flipNode${this.triangle.getId()}`);\n      flipNode.parent = rotationNode;\n      const scalingNode = new TransformNode(\n        `scalingNode${this.triangle.getId()}`,\n      );\n      flipNode.rotationQuaternion = Quaternion.Identity();\n\n      scalingNode.parent = flipNode;\n      this.triangleMesh.parent = scalingNode;\n      this.scalingNodeInitialPosition = scalingNode.position;\n    }\n  }\n\n  private setupPosition(scene: Scene, triangleMeshScalingRatio: number): void {\n    const positionNode = scene.getNodeByName(\n      `positionNode${this.triangle.getId()}`,\n    );\n    const rotationNode = scene.getNodeByName(\n      `rotationNode${this.triangle.getId()}`,\n    );\n    const scalingNode = scene.getNodeByName(\n      `scalingNode${this.triangle.getId()}`,\n    );\n\n    const triangleCenter = this.triangle.getCenterPoint();\n    const direction = triangleCenter; // Center - origin\n\n    const yawCorrection = 0;\n    const pitchCorrection = math.angle90;\n    const rollCorrection = 0;\n    if (positionNode && rotationNode && scalingNode && this.triangleMesh) {\n      (positionNode as TransformNode).setDirection(\n        direction,\n        yawCorrection,\n        pitchCorrection,\n        rollCorrection,\n      );\n      (rotationNode as TransformNode).position = new Vector3(\n        0,\n        direction.length(),\n        0,\n      );\n      (scalingNode as TransformNode).scaling = new Vector3(\n        triangleMeshScalingRatio,\n        triangleMeshScalingRatio,\n        triangleMeshScalingRatio,\n      );\n      const p1CenterVector = this.triangle.p1().subtract(triangleCenter);\n\n      const angle = Vector3.GetAngleBetweenVectors(\n        (rotationNode as TransformNode).forward,\n        p1CenterVector,\n        (rotationNode as TransformNode).up,\n      );\n\n      if (Math.abs(angle) > 0.05) {\n        (rotationNode as TransformNode).rotate(this.triangleMesh.up, angle);\n      } else if (DEBUG_RENDERING_ROTATION_NODE_ALIGNMENT) {\n        addAxisToScene({\n          scene,\n          size: 0.5,\n          parent: rotationNode as TransformNode,\n        });\n        MeshBuilder.CreateLines('line', {\n          points: [this.triangle.p1(), triangleCenter],\n        });\n      }\n    }\n  }\n\n  public computeBonesRotationAngle({\n    triangle,\n  }: {\n    triangle: Triangle;\n  }): number[] {\n    const triangleCenter = triangle.getCenterPoint();\n    const p1CenterVector = triangle.p1().subtract(triangleCenter);\n    const p2CenterVector = triangle.p2().subtract(triangleCenter);\n    const p3CenterVector = triangle.p3().subtract(triangleCenter);\n\n    const positionNode = this.scene.getNodeByName(\n      `positionNode${this.getTriangle().getId()}`,\n    );\n\n    if (positionNode) {\n      const angleP1ToP3 = Vector3.GetAngleBetweenVectors(\n        p1CenterVector,\n        p3CenterVector,\n        (positionNode as TransformNode).up,\n      );\n      const angleP1ToP2 = Vector3.GetAngleBetweenVectors(\n        p1CenterVector,\n        p2CenterVector,\n        (positionNode as TransformNode).up,\n      );\n      const deltaAngle1 = angleP1ToP3 - math.angle120;\n      const deltaAngle2 = angleP1ToP2 + math.angle120;\n\n      return [deltaAngle1, deltaAngle2, 0];\n    }\n    return [0, 0, 0];\n  }\n\n  public setAngleBonesRotation(rotations: number[]): void {\n    this.bonesRotationAngle = rotations;\n  }\n\n  public computeBonesDeformation(): Vector3[] {\n    // eslint-disable-next-line no-console\n    console.assert(\n      this.triangleMesh && this.triangleMesh.skeleton,\n      'Mesh and skeleton must exist',\n    );\n    if (this.triangleMesh && this.triangleMesh.skeleton) {\n      const skeletonMesh = this.triangleMesh.skeleton;\n\n      const bone1rotation = skeletonMesh.bones[0].rotation.clone();\n      const bone2rotation = skeletonMesh.bones[1].rotation.clone();\n      const bone3rotation = skeletonMesh.bones[2].rotation.clone();\n\n      bone1rotation.y += this.bonesRotationAngle[0];\n      bone2rotation.y += this.bonesRotationAngle[1];\n\n      return [bone1rotation, bone2rotation, bone3rotation];\n    }\n    return [Vector3.Zero(), Vector3.Zero(), Vector3.Zero()];\n  }\n\n  public computeBonesScaling(): number[] {\n    const triangleCenter = this.triangle.getCenterPoint();\n    const p1CenterVector = this.triangle.p1().subtract(triangleCenter);\n    const p2CenterVector = this.triangle.p2().subtract(triangleCenter);\n    const p3CenterVector = this.triangle.p3().subtract(triangleCenter);\n    if (\n      this.triangleMesh &&\n      this.triangleMesh.skeleton &&\n      this.equilateralTriangleRadius\n    ) {\n      const scaleBones = [\n        p3CenterVector.length() / this.equilateralTriangleRadius,\n        p2CenterVector.length() / this.equilateralTriangleRadius,\n        p1CenterVector.length() / this.equilateralTriangleRadius,\n      ];\n\n      return scaleBones;\n    }\n    return [1, 1, 1];\n  }\n\n  public setupMaterial(): void {\n    if (this.triangleMesh) {\n      const material = new StandardMaterial(\n        `meshMaterial${this.triangle.getId()}`,\n        this.scene,\n      );\n      material.diffuseColor = this.triangle.getColor();\n      material.backFaceCulling = false;\n      material.alpha = 1;\n      this.triangleMesh.material = material;\n    }\n  }\n\n  public getTriangle(): Triangle {\n    return this.triangle;\n  }\n\n  public getTriangleMesh(): Nullable<AbstractMesh> {\n    return this.triangleMesh;\n  }\n\n  public getVertices(): Nullable<Vector3[]> {\n    return this.triangleVertices;\n  }\n\n  public setVertices(vertices: Vector3[]): void {\n    this.triangleVertices = vertices;\n  }\n\n  public getEdges(): Nullable<Vector3[]> {\n    return this.triangleEdges;\n  }\n\n  public setEdges(edges: Vector3[]): void {\n    this.triangleEdges = edges;\n  }\n\n  public getScalingRatio(): number {\n    return this.scalingRatio;\n  }\n\n  public flip({\n    triangleMesh,\n    direction,\n    onFlipEnd,\n  }: {\n    triangleMesh: TriangleMesh;\n    direction: number;\n    onFlipEnd?: () => void;\n  }): void {\n    const context = {\n      adjacentTriangleMesh: triangleMesh,\n      direction,\n      onFlipEnd,\n    };\n    this.update(context);\n  }\n\n  public update(context?: {\n    adjacentTriangleMesh: TriangleMesh;\n    direction: number;\n    onFlipEnd?: () => void;\n  }): void {\n    const nextState = this.currentState.update(context);\n\n    if (nextState) {\n      this.currentState = nextState;\n    }\n  }\n\n  public isFlipping(): boolean {\n    return this.currentState.isFlipping();\n  }\n\n  public computeObjSpaceVertices(): Vector3[] | undefined {\n    if (this.triangle && this.triangleMesh) {\n      const tr = this.triangle;\n      const matrix = this.triangleMesh.computeWorldMatrix(true);\n      const vertices = [\n        Vector3.TransformCoordinates(tr.p1(), Matrix.Invert(matrix)),\n        Vector3.TransformCoordinates(tr.p2(), Matrix.Invert(matrix)),\n        Vector3.TransformCoordinates(tr.p3(), Matrix.Invert(matrix)),\n      ];\n\n      return vertices;\n    }\n    // eslint-disable-next-line no-console\n    console.assert(this.triangleMesh && this.triangle, 'Asset not found');\n    return undefined;\n  }\n\n  public computeObjSpaceEdges(vertices: Vector3[]): Vector3[] {\n    const edges = vertices.map((v, i) =>\n      v.subtract(vertices[(i + 1) % vertices.length]),\n    );\n    return edges;\n  }\n\n  public getAdjacentsVerticesMap(\n    adjTriangle: Triangle,\n  ): Record<string, number[]> {\n    const trVertices = this.triangle.getVertices();\n    const adjTrVertices = adjTriangle.getVertices();\n    const adjacentsMap: Record<string, number[]> = {\n      trAdjs: [],\n      adjTrAdjs: [],\n    };\n    if (trVertices && adjTrVertices) {\n      trVertices.forEach((trVertice: Vector3, indexTrVertice: number) => {\n        adjTrVertices.forEach(\n          (adjTrVertice: Vector3, indexAdjTrVertice: number) => {\n            if (adjTrVertice.subtract(trVertice).length() < k_epsilon) {\n              adjacentsMap.trAdjs.push(indexTrVertice);\n              adjacentsMap.adjTrAdjs.push(indexAdjTrVertice);\n            }\n          },\n        );\n      });\n    }\n    return adjacentsMap;\n  }\n\n  public getTriangleMeshBonesIndices(verticeIndices: number[]): number[] {\n    const bonesIndices: number[] = [];\n    verticeIndices.forEach((k, i) => {\n      switch (k) {\n        case 0:\n          bonesIndices[i] = 2;\n          break;\n        case 1:\n          bonesIndices[i] = 1;\n          break;\n        case 2:\n          bonesIndices[i] = 0;\n          break;\n        default:\n      }\n    });\n    return bonesIndices;\n  }\n\n  public getTriangleMeshIndicesSum(verticeIndices: number[]): number {\n    return verticeIndices.reduce((curr, prev) => curr + prev);\n  }\n\n  public getTriangleMeshFlipEdgeIndex(indicesSum: number): number {\n    switch (indicesSum) {\n      case 1:\n        return 0;\n      case 2:\n        return 2;\n      case 3:\n        return 1;\n      default:\n    }\n    // eslint-disable-next-line no-console\n    console.assert(true, 'return value should be a number beetwen 0 and 2');\n    return -1;\n  }\n\n  public getAngleBonesRotation(): number[] {\n    return this.bonesRotationAngle;\n  }\n\n  public reset(type: Type): void {\n    const mesh = this.triangleMesh;\n    if (mesh && mesh.skeleton) {\n      mesh.skeleton.bones.forEach((b, i) => {\n        if (this.skeletonBonesScaling) {\n          b.setScale(this.skeletonBonesScaling[i]);\n        }\n        if (this.skeletonBonesRotation) {\n          b.setRotation(this.skeletonBonesRotation[i]);\n        }\n      });\n    }\n    const scalingNode = mesh?.parent as TransformNode;\n    const flipNode = scalingNode.parent as TransformNode;\n    scalingNode.position = this.scalingNodeInitialPosition;\n    scalingNode.rotation.y = 0;\n    flipNode.position = this.scalingNodeInitialPosition;\n    flipNode.rotationQuaternion = new Quaternion(0, 0, 0, 1);\n\n    this.triangle.setType(type);\n    this.setupMaterial();\n  }\n}\n\nexport default TriangleMesh;\n","import { Vector3 } from '@babylonjs/core';\nimport { TriangleEdge } from 'models/Triangle';\nimport IIcosahedronDeserializer, {\n  Icosahedron,\n  Triangle,\n  Triangles,\n  ISubdivisionStrategy,\n} from './IIcosahedronDeserializer';\n\ninterface AdjacentJSON {\n  triangleId: number;\n}\ninterface VertexJSON {\n  _x: number;\n  _y: number;\n  _z: number;\n}\n\ninterface TriangleJson {\n  triangleId: bigint;\n  vertices: Array<VertexJSON>;\n  type: number;\n  adjacents: Array<AdjacentJSON>;\n}\n\nclass JsonIcosahedronDeserializer implements IIcosahedronDeserializer {\n  private version = '1.0.0';\n\n  public deserialize(\n    descriptor: string,\n    subdivisionStrategy: ISubdivisionStrategy,\n  ): Icosahedron {\n    const parsed = JSON.parse(descriptor, (key, value) => {\n      if (key === 'jsonSerializerVersion') {\n        // eslint-disable-next-line no-console\n        console.assert(\n          this.version === value,\n          'Mismatching serializer/deserializer versions',\n        );\n      }\n      return value;\n    });\n    const jsonTriangleMap = parsed.triangles.reduce(\n      (prev: any, curr: { triangleId: any }) => {\n        const id = `${curr.triangleId}`;\n        return { ...prev, [id]: curr };\n      },\n      {},\n    );\n    const triangles = parsed.triangles.map((triangle: TriangleJson) => {\n      const { triangleId, vertices, type } = triangle;\n      // eslint-disable-next-line no-underscore-dangle\n      const p1 = new Vector3(vertices[0]._x, vertices[0]._y, vertices[0]._z);\n      // eslint-disable-next-line no-underscore-dangle\n      const p2 = new Vector3(vertices[1]._x, vertices[1]._y, vertices[1]._z);\n      // eslint-disable-next-line no-underscore-dangle\n      const p3 = new Vector3(vertices[2]._x, vertices[2]._y, vertices[2]._z);\n\n      return new Triangle(triangleId, p1, p2, p3, type);\n    });\n    const triangleMap = triangles.reduce(\n      (prev: any, curr: { getId: () => bigint }) => {\n        const id = `${curr.getId()}`;\n        return { ...prev, [id]: curr };\n      },\n      {},\n    );\n    triangles.forEach((tr: Triangle) => {\n      const id = `${tr.getId()}`;\n      jsonTriangleMap[id].adjacents.forEach(\n        (adj: { triangleId: number }, idx: TriangleEdge) => {\n          tr.setAdjacent(triangleMap[`${adj.triangleId}`], idx);\n        },\n      );\n      return tr;\n    });\n    return new Icosahedron({\n      triangles,\n      subdivisionStrategy,\n    });\n  }\n}\nexport default JsonIcosahedronDeserializer;\n","import { Vector3 } from '@babylonjs/core';\nimport { k_epsilon } from 'game-constants/index';\nimport Triangle from 'models/Triangle';\n\nexport const isDuplicated = (\n  triangles: Triangle[],\n  triangle: Triangle,\n): boolean => !!triangles.find((e) => e.getId() === triangle.getId());\n\nexport const hasPoint = (tr: Triangle, point: Vector3): boolean =>\n  !!tr.getVertices().find((p) => p.subtract(point).length() < k_epsilon);\n\nexport const haveSameType = (tr1: Triangle, tr2: Triangle): boolean =>\n  tr1.getType() === tr2.getType();\n","import { Vector3 } from '@babylonjs/core';\nimport { Nullable } from '@babylonjs/core/types';\nimport Triangle from 'models/Triangle';\nimport { isDuplicated, hasPoint, haveSameType } from 'gameplay/utils';\n\nexport type Hexagon = Triangle[];\nexport type Hexagons = Hexagon[];\n\nexport const shapesVerify = (triangles: Triangle[]): Hexagons => {\n  const shapes: Hexagons = [];\n  triangles.forEach((tr) => {\n    const shapesList = [\n      { pivotPoint: tr.p1(), adjsPivotPoint: getAdjacentsToPoint(tr, 1) },\n      { pivotPoint: tr.p2(), adjsPivotPoint: getAdjacentsToPoint(tr, 2) },\n      { pivotPoint: tr.p3(), adjsPivotPoint: getAdjacentsToPoint(tr, 0) },\n    ]\n      .map(({ pivotPoint, adjsPivotPoint }) =>\n        findHexagon(tr, pivotPoint, adjsPivotPoint),\n      )\n      .filter((hex) => !!hex) as Hexagons;\n    shapesList.forEach((hex: Hexagon) => shapes.push(hex));\n  });\n\n  return shapes;\n};\n\nconst findHexagon = (\n  tr: Triangle,\n  point: Vector3,\n  adjs: Triangle[],\n): Nullable<Hexagon> => {\n  const shape: Triangle[] = [tr];\n  if (\n    adjs[0] &&\n    adjs[1] &&\n    haveSameType(tr, adjs[0]) &&\n    haveSameType(tr, adjs[1])\n  ) {\n    shape.push(adjs[0]);\n    shape.push(adjs[1]);\n    adjs.forEach((adj) => {\n      const adjs2 = adj\n        ?.getAdjacents()\n        .find(\n          (adj2) =>\n            adj2?.getType() === tr.getType() &&\n            adj2.getId() !== tr.getId() &&\n            hasPoint(adj2, point),\n        );\n\n      if (adjs2) {\n        if (!isDuplicated(shape, adjs2)) {\n          shape.push(adjs2);\n        }\n\n        if (adj && hasPoint(adjs2, point)) {\n          const adjs3 = adjs2\n            ?.getAdjacents()\n            .find(\n              (adj3) =>\n                adj3?.getType() === tr.getType() &&\n                adj3.getId() !== adj.getId() &&\n                hasPoint(adj3, point),\n            );\n\n          if (adjs3 && hasPoint(adjs3, point)) {\n            if (!isDuplicated(shape, adjs3)) {\n              shape.push(adjs3);\n            }\n          }\n        }\n      }\n    });\n  }\n  if (shape.length === 6) {\n    const hexagon = shape as Hexagon;\n    return hexagon;\n  }\n\n  return null;\n};\n\nconst getAdjacentsToPoint = (tr: Triangle, index: number): Triangle[] =>\n  tr.getAdjacents().filter((a, i) => i !== index) as Triangle[];\n","import { ArcRotateCamera, Vector3, Scene } from '@babylonjs/core';\n\nconst setupCamera = (scene: Scene, target: Vector3): ArcRotateCamera => {\n  const alpha = -Math.PI * 0.5;\n  const beta = Math.PI * 0.4;\n  const radius = 3;\n  const camera = new ArcRotateCamera(\n    'camera',\n    alpha,\n    beta,\n    radius,\n    target,\n    scene,\n  );\n  camera.minZ = 0.1;\n  camera.lowerRadiusLimit = 1.5; // we dont' want to get too close\n  return camera;\n};\n\nexport default setupCamera;\n","import { Scene, HemisphericLight, Vector3 } from '@babylonjs/core';\n\nconst setupLight = (scene: Scene, target: Vector3): void => {\n  const light = new HemisphericLight('light', new Vector3(0, 1, 0), scene);\n  light.intensity = 1.1;\n  light.setDirectionToTarget(target);\n  // light.parent = camera;\n};\n\nexport default setupLight;\n","import {\n  TransformNode,\n  Vector3,\n  Scene,\n  Mesh,\n  StandardMaterial,\n  VertexData,\n  Color3,\n  MeshBuilder,\n  PointerEventTypes,\n} from '@babylonjs/core';\nimport {\n  DEBUG_RENDERING_ADJACENTS,\n  DEBUG_RENDERING_ALL_TRIANGLES_CENTER,\n} from 'game-constants/debug';\n\nimport Triangle, { TriangleId } from 'models/Triangle';\n\nconst getMeshName = (triangleId: TriangleId): string => {\n  const meshName = `Input${triangleId}`;\n  return meshName;\n};\n\nconst generateInputMesh = (\n  name: string,\n  scene: Scene,\n  triangles: Array<Triangle>,\n  renderNormals = false,\n): void => {\n  //\n  const rootNode = new TransformNode(name, scene);\n\n  triangles.forEach((triangle) => {\n    if (DEBUG_RENDERING_ALL_TRIANGLES_CENTER) {\n      const line = MeshBuilder.CreateLines(`tr${triangle.getName()}`, {\n        points: [\n          triangle.getCenterPoint().scale(1.05),\n          triangle.getCenterPoint(),\n        ],\n      });\n      line.color = new Color3(0, 0, 0);\n    }\n\n    const vertexData = createVertexData(triangle, renderNormals);\n    const meshName = getMeshName(triangle.getId());\n    const mesh = createMesh(meshName, scene, vertexData);\n    mesh.parent = rootNode;\n    mesh.metadata = { triangle };\n  });\n\n  if (DEBUG_RENDERING_ADJACENTS) {\n    scene.onPointerObservable.add((pointerInfo) => {\n      switch (pointerInfo.type) {\n        case PointerEventTypes.POINTERDOWN:\n          {\n            const mesh =\n              pointerInfo?.pickInfo?.hit && pointerInfo.pickInfo.pickedMesh;\n            const metadata = mesh && mesh.metadata;\n            if (metadata) {\n              const { triangle } = metadata;\n              const adjacentIds: Array<TriangleId> = triangle\n                .getAdjacents()\n                .map((tr: Triangle) => tr?.getId() || -1);\n\n              adjacentIds.forEach((adjId) => {\n                const adjMesh = scene.getMeshByName(getMeshName(adjId));\n\n                if (adjMesh && adjMesh.material) {\n                  adjMesh.material.alpha = 0.5;\n                  const mat: StandardMaterial =\n                    adjMesh.material as StandardMaterial;\n                  mat.diffuseColor = new Color3(0, 0, 0);\n                }\n              });\n            }\n          }\n\n          break;\n        default:\n          break;\n      }\n    });\n  }\n};\n\nconst createVertexData = (triangle: Triangle, renderNormals: boolean) => {\n  const normals: Array<number> = [];\n  const indices: Array<number> = [0, 1, 2];\n  const positions = triangle\n    .getVertices()\n    .reduce(\n      (prev: number[], curr: Vector3): number[] => [\n        ...prev,\n        curr.x,\n        curr.y,\n        curr.z,\n      ],\n      [],\n    );\n  const vertexData = new VertexData();\n  VertexData.ComputeNormals(positions, indices, normals);\n\n  vertexData.positions = positions;\n  vertexData.indices = indices;\n  vertexData.normals = normals;\n\n  if (renderNormals) {\n    // Setup to debugging triangles face direction\n    {\n      const options = {\n        points: [\n          triangle.p1(),\n          triangle.p1().add(new Vector3(normals[0], normals[1], normals[2])),\n        ],\n        updatable: true,\n      };\n      const lines = MeshBuilder.CreateLines('lines', options);\n      lines.color = new Color3(1, 0, 0);\n    }\n    {\n      const options = {\n        points: [\n          triangle.p2(),\n          triangle.p2().add(new Vector3(normals[3], normals[4], normals[5])),\n        ],\n        updatable: true,\n      };\n      const lines = MeshBuilder.CreateLines('lines', options);\n      lines.color = new Color3(1, 0, 0);\n    }\n    {\n      const options = {\n        points: [\n          triangle.p3(),\n          triangle.p3().add(new Vector3(normals[6], normals[7], normals[8])),\n        ],\n        updatable: true,\n      };\n      const lines = MeshBuilder.CreateLines('lines', options);\n      lines.color = new Color3(1, 0, 0);\n    }\n  }\n\n  return vertexData;\n};\n\nconst createMesh = (\n  name: string,\n  scene: Scene,\n  vertexData: VertexData,\n): Mesh => {\n  const customMesh = new Mesh(name, scene);\n  customMesh.isPickable = true;\n  const material = new StandardMaterial('myMaterial', scene);\n  const hue = Math.random() * 255;\n  const saturation = 1;\n  const value = 1;\n  Color3.HSVtoRGBToRef(hue, saturation, value, material.diffuseColor);\n  material.backFaceCulling = false;\n  material.alpha = 0;\n  customMesh.material = material;\n  vertexData.applyToMesh(customMesh, true);\n  return customMesh;\n};\n\nexport default generateInputMesh;\n","import { ArcRotateCamera, Scene } from '@babylonjs/core';\nimport Triangle from 'models/Triangle';\nimport generateInputMesh from './generateInputMesh';\n\nconst setupInput = (\n  scene: Scene,\n  camera: ArcRotateCamera,\n  triangles: Triangle[],\n): void => {\n  const canvas = scene.getEngine().getRenderingCanvas();\n  camera.attachControl(canvas, true);\n  generateInputMesh('icosahedron', scene, triangles);\n};\n\nexport default setupInput;\n","import {\n  Scene,\n  PointerEventTypes,\n  ArcRotateCamera,\n  AbstractMesh,\n} from '@babylonjs/core';\n\nimport Triangle from 'models/Triangle';\nimport Gesture, { GestureId } from './Gesture';\nimport FlipGesture from './FlipGesture';\nimport setupInput from './setupInput';\n\nclass InputManager {\n  //\n  private scene: Scene;\n\n  private gesturesMap: Record<GestureId, Gesture> = {};\n\n  public constructor(\n    scene: Scene,\n    camera: ArcRotateCamera,\n    triangles: Triangle[],\n  ) {\n    this.scene = scene;\n    setupInput(scene, camera, triangles);\n  }\n\n  public onMeshLoaded(triangleMesh: AbstractMesh): void {\n    this.scene.onPointerObservable.add((pointerInfo) => {\n      const { pointerId } = pointerInfo.event;\n      switch (pointerInfo.type) {\n        case PointerEventTypes.POINTERDOWN:\n        case PointerEventTypes.POINTERTAP:\n          {\n            const mesh =\n              pointerInfo?.pickInfo?.hit && pointerInfo.pickInfo.pickedMesh;\n            if (mesh) {\n              const gestureContext = {\n                scene: this.scene,\n                triangleMesh,\n                onFlipEnded: () => {\n                  delete this.gesturesMap[pointerId];\n                },\n              };\n              this.gesturesMap[pointerId] = new FlipGesture(gestureContext);\n              this.gesturesMap[pointerId].onDown(pointerInfo);\n            }\n          }\n          break;\n\n        case PointerEventTypes.POINTERMOVE:\n          {\n            let gesture = this.gesturesMap[pointerId];\n            if (!gesture) {\n              const gestureContext = {\n                scene: this.scene,\n                triangleMesh,\n                onFlipEnded: () => {\n                  delete this.gesturesMap[pointerId];\n                },\n              };\n              gesture = new FlipGesture(gestureContext);\n              this.gesturesMap[pointerId] = gesture;\n            }\n\n            gesture.onMove(pointerInfo);\n          }\n          break;\n        case PointerEventTypes.POINTERUP:\n          {\n            const gesture = this.gesturesMap[pointerId];\n            if (gesture) {\n              gesture.onRelease(pointerInfo);\n            }\n            delete this.gesturesMap[pointerId];\n          }\n          break;\n        default:\n          break;\n      }\n    });\n  }\n}\n\nexport default InputManager;\n","import {\n  Vector3,\n  Scene,\n  SceneLoader,\n  ArcRotateCameraPointersInput,\n} from '@babylonjs/core';\nimport {\n  k_triangleAssetName,\n  k_triangleAssetDebugFileName,\n  k_triangleAssetPath,\n} from 'game-constants/identifiers';\nimport Icosahedron from 'models/Icosahedron';\nimport _1to4SubdivisionStrategy from 'models/Icosahedron/SubdivisionStrategy/1to4SubdivisionStrategy';\nimport TriangleMesh from 'rendering/TriangleMesh/index';\nimport JsonIcosahedronDeserializer from 'deserializers/JsonIcosahedronDeserializer';\n// import JsonIcosahedronSerializer from 'serializers/JsonIcosahedronSerializer'; // #Serialization\nimport {\n  shapesVerify,\n  Hexagon,\n  Hexagons,\n} from 'gameplay/ShapeDetector/shapesVerify';\nimport Triangle from 'models/Triangle';\nimport setupCamera from 'components/GameComponent/setupCamera';\nimport setupLight from 'components/GameComponent/setupLight';\nimport InputManager from 'components/GameComponent/InputManager';\nimport { DEBUG_RENDERING_ADJS_TRIANGLES_BY_ID } from 'game-constants/debug';\nimport { adjsTrianglesDebug } from 'utils';\n\nconst useGameLogic = (): {\n  onRender: (scene: Scene) => void;\n  onSceneReady: (sceneArg: Scene) => void;\n} => {\n  const loadIcosahedron = async () => {\n    const subdivisionStrategy = new _1to4SubdivisionStrategy();\n    try {\n      const json = await fetch('assets/data/icosahedron-0.json').then(\n        (response) => response.text(),\n      );\n      if (json && json.length) {\n        // eslint-disable-next-line no-console\n        console.log('Icosahedron JSON file loaded.');\n        const deserializer = new JsonIcosahedronDeserializer();\n        return deserializer.deserialize(json, subdivisionStrategy);\n      }\n    } catch (e) {\n      // eslint-disable-next-line no-console\n      console.log('Icosahedron JSON file was not found.');\n    }\n    const icosahedron = new Icosahedron({ subdivisionStrategy });\n    icosahedron.subdivide(2);\n    // #Serialization\n    // const serializer = new JsonIcosahedronSerializer();\n    // const json = serializer.serialize(icosahedron);\n    // eslint-disable-next-line no-console\n    // console.log('Icosahedron json', json);\n    return icosahedron;\n  };\n\n  const onSceneReady = async (sceneArg: Scene) => {\n    const scene: Scene = sceneArg;\n    const target = new Vector3(0, 0, 0);\n    const camera = setupCamera(scene, target);\n    (camera.inputs.attached.pointers as ArcRotateCameraPointersInput).buttons =\n      [1];\n    const icosahedron = await loadIcosahedron();\n    // console.log('Icosahedron loaded');\n    icosahedron.registerOnTriangleChanged((triangles) => {\n      const hexagons: Hexagons = shapesVerify(triangles);\n\n      if (hexagons) {\n        hexagons.forEach((hex: Hexagon) => {\n          if (hex) {\n            hex.forEach((tr) => {\n              const mesh = scene.getMeshByName(tr.getName());\n              const trMesh = mesh && mesh.metadata.triangleMesh;\n              trMesh.reset(Triangle.getRandomType());\n            });\n          }\n        });\n      }\n    });\n\n    const triangles = icosahedron.getTriangles();\n\n    scene.metadata = { icosahedron };\n\n    const inputManager = new InputManager(scene, camera, triangles);\n    setupLight(scene, target);\n\n    SceneLoader.ImportMeshAsync(\n      k_triangleAssetName,\n      k_triangleAssetPath,\n      k_triangleAssetDebugFileName,\n    ).then(({ meshes, skeletons }) => {\n      if (meshes && meshes.length > 0 && skeletons) {\n        const assetMesh = meshes[0];\n\n        const trianglesMeshesToRender = DEBUG_RENDERING_ADJS_TRIANGLES_BY_ID\n          ? adjsTrianglesDebug(triangles, 361)\n          : triangles;\n\n        const triangleMeshes = trianglesMeshesToRender.map(\n          (tr) =>\n            new TriangleMesh({\n              scene,\n              triangle: tr,\n              equilateralTriangleProvider: icosahedron,\n            }),\n        );\n        assetMesh.visibility = 0;\n\n        scene.registerBeforeRender(() => {\n          triangleMeshes.forEach((t) => t.update());\n        });\n\n        inputManager.onMeshLoaded(assetMesh);\n      }\n    });\n  };\n\n  const onRender = (scene: Scene) => {\n    const root = scene.getTransformNodeByName('root');\n    if (root) {\n      // const deltaTimeInMillis = scene.getEngine().getDeltaTime();\n      // const rpm = 5;\n      // root.rotation.y += (rpm / 60) * Math.PI * 2 * (deltaTimeInMillis / 1000);\n    }\n  };\n\n  return { onRender, onSceneReady };\n};\n\nexport default useGameLogic;\n","import { Engine, EngineOptions, Scene, SceneOptions } from '@babylonjs/core';\n// fixme: enable this import only on debug\nimport '@babylonjs/inspector';\nimport { DEBUG_RENDERING_WORLD_AXIS } from 'game-constants/debug';\n\nimport React, { useEffect, useRef } from 'react';\nimport { addAxisToScene } from 'utils';\n\ntype onRenderCallback = (a: Scene) => void;\ntype onSceneReadyCallback = (a: Scene) => void;\n\ninterface SceneComponentProps {\n  antialias?: boolean;\n  engineOptions?: EngineOptions;\n  adaptToDeviceRatio?: boolean;\n  sceneOptions?: SceneOptions;\n  onRender: onRenderCallback;\n  onSceneReady: onSceneReadyCallback;\n}\n\nconst SceneComponent: React.FC<SceneComponentProps> = (props) => {\n  const reactCanvas = useRef(null);\n  const {\n    antialias,\n    engineOptions,\n    adaptToDeviceRatio,\n    sceneOptions,\n    //\n    onRender,\n    onSceneReady,\n    ...rest\n  } = props;\n\n  useEffect(() => {\n    if (reactCanvas.current) {\n      const engine = new Engine(\n        reactCanvas.current,\n        antialias,\n        engineOptions,\n        adaptToDeviceRatio,\n      );\n      const scene = new Scene(engine, sceneOptions);\n      if (scene.isReady()) {\n        onSceneReady(scene);\n      } else {\n        scene.onReadyObservable.addOnce((observedScene) =>\n          onSceneReady(observedScene),\n        );\n      }\n\n      engine.runRenderLoop(() => {\n        if (typeof onRender === 'function') {\n          onRender(scene);\n        }\n        scene.render();\n      });\n\n      const resize = () => {\n        scene.getEngine().resize();\n      };\n\n      if (window) {\n        window.addEventListener('resize', resize);\n      }\n\n      if (DEBUG_RENDERING_WORLD_AXIS) {\n        scene.debugLayer.show();\n        // WORLD AXIS\n        addAxisToScene({ scene, size: 5 });\n      }\n\n      return () => {\n        scene.getEngine().dispose();\n\n        if (window) {\n          window.removeEventListener('resize', resize);\n        }\n      };\n    }\n    return undefined;\n  }, [reactCanvas]);\n\n  return (\n    <canvas\n      ref={reactCanvas}\n      width={window.innerWidth}\n      height={window.innerHeight}\n      {...rest}\n    />\n  );\n};\nexport default SceneComponent;\n","import React from 'react';\nimport useGameLogic from 'gameplay/game/useGameLogic';\nimport SceneComponent from 'components/SceneComponent';\n\nconst GameComponent: React.FC = () => {\n  const { onRender, onSceneReady } = useGameLogic();\n  return (\n    <SceneComponent antialias onSceneReady={onSceneReady} onRender={onRender} />\n  );\n};\n\nexport default GameComponent;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import App from './App';\nimport { Route, BrowserRouter, Routes } from 'react-router-dom';\nimport GameComponent from './components/GameComponent/index';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <BrowserRouter basename={process.env.REACT_APP_BASE_PATH}>\n      <Routes>\n        <Route path=\"/\" element={<GameComponent />} />\n      </Routes>\n    </BrowserRouter>\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}